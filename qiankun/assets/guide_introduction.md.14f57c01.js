import{_ as t,o as r,c as n,U as o}from"./chunks/framework.f5b89f62.js";const _=JSON.parse('{"title":"介绍","description":"","frontmatter":{},"headers":[],"relativePath":"guide/introduction.md","filePath":"guide/introduction.md"}'),a={name:"guide/introduction.md"},i=o('<h1 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h1><p>qiankun 是一个基于 <a href="https://github.com/CanopyTax/single-spa" target="_blank" rel="noreferrer">single-spa</a> 的<a href="https://micro-frontends.org/" target="_blank" rel="noreferrer">微前端</a>实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p><h2 id="什么是微前端" tabindex="-1">什么是微前端 <a class="header-anchor" href="#什么是微前端" aria-label="Permalink to &quot;什么是微前端&quot;">​</a></h2><p>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。</p><p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题。</p><p>微前端架构的核心思想是：<strong>一个应用由多个前端应用组成</strong>。每个前端应用都是一个<strong>独立的小团队</strong>通过<strong>独立的开发、测试、部署</strong>来进行<strong>独立的业务开发</strong>。在用户访问过程中，根据用户的访问路径，将不同的前端应用组合成一个完整的应用。</p><h2 id="为什么要使用微前端" tabindex="-1">为什么要使用微前端 <a class="header-anchor" href="#为什么要使用微前端" aria-label="Permalink to &quot;为什么要使用微前端&quot;">​</a></h2><p>微前端架构的核心目标是将巨石应用拆分成多个可以自治的小应用，从而达到以下目标：</p><ul><li><p><strong>技术栈无关</strong>：主框架不限制接入应用的技术栈，微应用具备完全自主权</p></li><li><p><strong>独立开发、独立部署</strong>：微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p></li><li><p><strong>增量升级</strong>：在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</p></li><li><p><strong>独立运行时</strong>：每个微应用之间状态隔离，运行时状态不共享</p></li></ul><h2 id="微前端应用场景" tabindex="-1">微前端应用场景 <a class="header-anchor" href="#微前端应用场景" aria-label="Permalink to &quot;微前端应用场景&quot;">​</a></h2><ul><li><p><strong>多个团队</strong>：多个团队独立开发</p></li><li><p><strong>多个项目</strong>：多个项目整合</p></li><li><p><strong>独立开发</strong>：独立开发、独立部署</p></li><li><p><strong>增量升级</strong>：渐进式重构</p></li><li><p><strong>独立运行时</strong>：每个微应用之间状态隔离，运行时状态不共享</p></li></ul><h2 id="微前端的缺点" tabindex="-1">微前端的缺点 <a class="header-anchor" href="#微前端的缺点" aria-label="Permalink to &quot;微前端的缺点&quot;">​</a></h2><ul><li><p><strong>性能问题</strong>：每个微应用都有自己的依赖库和框架，这可能导致大量重复的代码和更大的应用大小。此外，多个运行时可能会导致内存和CPU资源的浪费。</p></li><li><p><strong>增加了复杂性</strong>：微前端架构需要一个微服务的基础设施来支持它。你需要实现路由、状态管理、通信机制等微前端所需的功能，这都会增加应用的复杂性。</p></li><li><p><strong>团队间的沟通成本增加</strong>：每个微应用由不同的团队开发和维护，这可能导致沟通和协作的困难。尤其是在跨应用的特性开发和bug修复时，需要很好的团队间的协调和沟通。</p></li><li><p><strong>技术栈不一致问题</strong> ：不同的微应用可能使用不同的技术栈，这可能导致应用的一致性问题。虽然微前端架构允许使用不同的技术栈，但对于用户来说，应用间的切换应该是无缝的。</p></li><li><p><strong>安全性问题</strong>：在微前端架构中，每个微应用都是独立的，因此需要单独处理安全问题，比如防止跨站脚本攻击（XSS）等。</p></li><li><p><strong>测试的复杂性增加</strong>：由于每个微应用都是独立的，因此每个应用都需要进行单独的测试。同时，你还需要进行集成测试来确保所有应用能够正常协同工作。</p></li></ul><h2 id="常见微前端的实现方式" tabindex="-1">常见微前端的实现方式 <a class="header-anchor" href="#常见微前端的实现方式" aria-label="Permalink to &quot;常见微前端的实现方式&quot;">​</a></h2><ul><li><p><strong>iframe 沙箱</strong>：这种方式最为简单。每个微应用都在各自的 iframe 中独立运行。这种方法的优点是隔离性好，微应用之间不会互相影响。但缺点也明显，包括 iframe 的性能问题、微应用之间的通信复杂以及无法共享上下文和组件等。为什么不使用iframe，具体可以查看<a href="https://www.yuque.com/kuitos/gky7yw/gesexv" target="_blank" rel="noreferrer">这里</a>。</p></li><li><p><strong>Web Components</strong>：Web Components 是一种浏览器原生支持的技术，它允许创建可重用的自定义元素，并在其内部封装它们的功能。每个微应用都可以作为一个 web component，从而实现隔离。然而，这种方式的问题在于 web components 的浏览器兼容性。</p></li><li><p><strong>JavaScript 框架</strong>： 这种方式依赖于 JavaScript 框架，比如 Single-SPA、qiankun 等。这些框架提供了微前端的解决方案，可以帮助我们进行微应用的加载、卸载、切换等，同时也提供了一些通信机制。但是这种方式需要引入额外的库和框架，可能会增加项目的复杂性。</p></li></ul><h2 id="qiankun-的特性" tabindex="-1">qiankun 的特性 <a class="header-anchor" href="#qiankun-的特性" aria-label="Permalink to &quot;qiankun 的特性&quot;">​</a></h2><ul><li><p><strong>技术栈无关</strong>：主框架不限制接入应用的技术栈，微应用具备完全自主权</p></li><li><p><strong>HTML Entry 接入方式</strong>：微应用接入方只需要提供一个入口 html，即可接入微前端系统的任意位置</p></li><li><p><strong>样式隔离</strong>：确保微应用之间样式互相不干扰</p></li><li><p><strong>JS 沙箱</strong>：确保微应用之间 全局变量/事件 不冲突</p></li><li><p><strong>HTML 沙箱</strong>：确保微应用之间 DOM 结构不冲突</p></li><li><p><strong>prefetch 预加载</strong>：在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度</p></li></ul>',17),e=[i];function l(s,p,g,h,u,c){return r(),n("div",null,e)}const m=t(a,[["render",l]]);export{_ as __pageData,m as default};
