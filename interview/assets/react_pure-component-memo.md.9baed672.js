import{_ as s,o as n,c as o,U as a}from"./chunks/framework.8610b7e0.js";const A=JSON.parse('{"title":"React中的PureComponent和memo有什么区别？","description":"","frontmatter":{},"headers":[],"relativePath":"react/pure-component-memo.md","filePath":"react/pure-component-memo.md"}'),l={name:"react/pure-component-memo.md"},p=a(`<h1 id="react中的purecomponent和memo有什么区别" tabindex="-1">React中的PureComponent和memo有什么区别？ <a class="header-anchor" href="#react中的purecomponent和memo有什么区别" aria-label="Permalink to &quot;React中的PureComponent和memo有什么区别？&quot;">​</a></h1><h2 id="react-purecomponent" tabindex="-1">React.PureComponent <a class="header-anchor" href="#react-purecomponent" aria-label="Permalink to &quot;React.PureComponent&quot;">​</a></h2><p><code>PureComponent</code> 是 React 中一个用于性能优化的组件类。与 <code>React.Component</code> 相比，<code>React.PureComponent</code> 自动实现了 <code>shouldComponentUpdate</code> 生命周期方法。这使得组件仅在其 <code>props</code> 或 <code>state</code> 发生浅层比较（shallow comparison）不同时，才会重新渲染。</p><p>下面是一个简单的例子：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">PureComponent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MyPureComponent</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PureComponent</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">render</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">MyPureComponent render</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{this.</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> MyPureComponent</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>使用 <code>PureComponent</code> 的注意事项：</p><ol><li><p><strong>浅层比较（Shallow Comparison）</strong>: 因为 <code>PureComponent</code> 只执行浅层比较，所以它不适用于复杂的对象和数组结构。如果对象和数组内部发生变化，但引用没有变，浅层比较将不会识别出这一点。</p></li><li><p><strong>不适用于函数组件</strong>: 函数组件应使用 <code>React.memo</code>，它是一个与 <code>PureComponent</code> 类似的功能，但适用于函数组件。</p></li><li><p><strong>副作用和外部变量</strong>: 如果组件的渲染依赖于外部变量或有副作用（如 API 调用），则 <code>PureComponent</code> 可能不是最佳选择。</p></li><li><p><strong>资源开销</strong>: 虽然减少了不必要的渲染，但浅层比较本身也是有成本的。在极少数情况下，这可能会导致性能问题。</p></li></ol><p>使用 <code>PureComponent</code> 是一种优化手段，而不是每个组件都应该使用的。通常情况下，应当先构建应用程序，然后再考虑性能优化。当你确实面临性能问题时，使用 React DevTools 等工具来识别问题组件，然后再考虑使用 <code>PureComponent</code>。</p><h2 id="react-memo" tabindex="-1">React.memo <a class="header-anchor" href="#react-memo" aria-label="Permalink to &quot;React.memo&quot;">​</a></h2><p><code>React.memo</code> 是一个高阶组件，它与 <code>React.PureComponent</code> 非常类似，但适用于函数组件而不是类组件。它会进行 props 的浅层比较，并决定是否重新渲染函数组件。</p><p>假设你有一个函数组件如下：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MyComponent</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">MyComponent render</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>你可以使用 <code>React.memo</code> 将其转换为一个 &quot;记忆&quot; 组件，这样只有在 <code>props</code> 发生变化时才会重新渲染：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyMemoizedComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">memo</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MyComponent</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">MyComponent render</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>或者更简洁地：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyMemoizedComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">memo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">MyComponent render</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>这样，只有当 <code>name</code> 属性发生变化时，<code>MyMemoizedComponent</code> 才会重新渲染。</p><h3 id="使用注意事项" tabindex="-1">使用注意事项： <a class="header-anchor" href="#使用注意事项" aria-label="Permalink to &quot;使用注意事项：&quot;">​</a></h3><ol><li><p><strong>浅层比较</strong>: <code>React.memo</code> 仅检查 <code>props</code> 的浅层比较。如果你传递了复杂的对象或数组，并在内部进行了修改，它不会触发重新渲染。</p></li><li><p><strong>自定义比较</strong>: 你可以提供一个自定义比较函数作为 <code>React.memo</code> 的第二个参数。这类似于 <code>shouldComponentUpdate</code> 的功能。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">areEqual</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">prevProps</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">nextProps</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 返回 true 如果 props 相等，否则返回 false</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyMemoizedComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">memo</span><span style="color:#A6ACCD;">(MyComponent</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> areEqual)</span><span style="color:#89DDFF;">;</span></span></code></pre></div></li><li><p><strong>性能考虑</strong>: 在某些情况下，使用 <code>memo</code> 可能会引入额外的性能开销，比如进行 props 比较的成本。</p></li><li><p><strong>只用于优化</strong>: 不应该在业务逻辑中依赖 <code>React.memo</code> 来阻止渲染，因为未来的 React 版本可能会因为某些优化原因而改变这一行为。</p></li></ol><p><code>React.memo</code> 主要用于性能优化。通常，你应当首先进行应用开发，只有在性能确实成问题时才使用 <code>React.memo</code>。</p><h2 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h2><p><code>React.PureComponent</code> 和 <code>React.memo</code> 都用于优化 React 组件的重新渲染，但它们适用于不同类型的组件并有一些细微的差异。</p><h3 id="react-purecomponent-1" tabindex="-1"><code>React.PureComponent</code> <a class="header-anchor" href="#react-purecomponent-1" aria-label="Permalink to &quot;\`React.PureComponent\`&quot;">​</a></h3><ol><li><p><strong>适用于类组件</strong>: <code>PureComponent</code> 是一个 React 类组件。</p></li><li><p><strong>自动浅层比较</strong>: 它通过对 <code>props</code> 和 <code>state</code> 进行浅层比较自动避免不必要的重新渲染。</p></li><li><p><strong>生命周期方法</strong>: 因为 <code>PureComponent</code> 是类组件，你可以使用生命周期方法。</p></li><li><p><strong>不可定制比较</strong>: <code>PureComponent</code> 的浅比较是固定的，你不能更改比较逻辑。</p></li></ol><p>示例：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MyComponent</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">PureComponent</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">render</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{this.</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="react-memo-1" tabindex="-1"><code>React.memo</code> <a class="header-anchor" href="#react-memo-1" aria-label="Permalink to &quot;\`React.memo\`&quot;">​</a></h3><ol><li><p><strong>适用于函数组件</strong>: <code>memo</code> 是一个高阶组件，用于包装函数组件。</p></li><li><p><strong>自动浅层比较</strong>: 默认情况下，它也进行 <code>props</code> 的浅层比较。</p></li><li><p><strong>可定制比较</strong>: 你可以提供一个自定义的比较函数作为 <code>React.memo</code> 的第二个参数。</p></li></ol><p>示例：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">memo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>或带有自定义比较函数：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">memo</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">prevProps</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">nextProps</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">prevProps</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">nextProps</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h3 id="相同点" tabindex="-1">相同点 <a class="header-anchor" href="#相同点" aria-label="Permalink to &quot;相同点&quot;">​</a></h3><ol><li>两者都只进行浅层比较，以决定是否重新渲染。</li><li>两者都用于优化组件的性能。</li></ol><h3 id="不同点" tabindex="-1">不同点 <a class="header-anchor" href="#不同点" aria-label="Permalink to &quot;不同点&quot;">​</a></h3><ol><li><code>PureComponent</code> 用于类组件，而 <code>memo</code> 用于函数组件。</li><li><code>PureComponent</code> 不允许自定义比较逻辑，而 <code>memo</code> 允许。</li><li>由于 <code>PureComponent</code> 是类组件，它可以使用生命周期方法，而 <code>memo</code> 封装的是函数组件。</li></ol><p>综上所述，选择使用哪一个主要取决于你是在使用类组件还是函数组件，以及是否需要自定义比较逻辑。</p>`,37),e=[p];function t(c,r,y,D,F,C){return n(),o("div",null,e)}const d=s(l,[["render",t]]);export{A as __pageData,d as default};
