import{_ as e,o,c as s,U as a}from"./chunks/framework.8610b7e0.js";const S=JSON.parse('{"title":"CSRF","description":"","frontmatter":{},"headers":[],"relativePath":"security/csrf.md","filePath":"security/csrf.md"}'),t={name:"security/csrf.md"},r=a('<h1 id="csrf" tabindex="-1">CSRF <a class="header-anchor" href="#csrf" aria-label="Permalink to &quot;CSRF&quot;">​</a></h1><h3 id="csrf-跨站请求伪造-是什么" tabindex="-1">CSRF（跨站请求伪造）是什么 <a class="header-anchor" href="#csrf-跨站请求伪造-是什么" aria-label="Permalink to &quot;CSRF（跨站请求伪造）是什么&quot;">​</a></h3><p>CSRF（Cross-Site Request Forgery）是一种网络攻击，其中攻击者诱使已经认证的用户在不知情的情况下发送请求到一个他们已经认证过的应用程序。这种攻击利用了网站对用户浏览器的信任，从而执行非预期的操作。</p><h3 id="csrf-攻击的具体例子" tabindex="-1">CSRF 攻击的具体例子 <a class="header-anchor" href="#csrf-攻击的具体例子" aria-label="Permalink to &quot;CSRF 攻击的具体例子&quot;">​</a></h3><p>假设 Alice 登录了她的银行账户，并且银行网站在她的浏览器中设置了一个会话 Cookie。在不登出银行网站的情况下，她访问了另一个网站，该网站包含了以下恶意 HTML 图片元素：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">img</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">http://bank.com/transfer?amount=1000&amp;to=attacker</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">style</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">display:none;</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>这个图片请求实际上是一个向银行发起的转账请求。因为 Alice 的浏览器仍然持有她的银行会话，所以银行网站可能会认为这是一个有效的请求，并执行转账操作。</p><h3 id="csrf-防御措施" tabindex="-1">CSRF 防御措施 <a class="header-anchor" href="#csrf-防御措施" aria-label="Permalink to &quot;CSRF 防御措施&quot;">​</a></h3><ol><li><p><strong>使用 CSRF 令牌</strong>: 最常见的防御方式是在表单中使用一个随机生成的 CSRF 令牌，这个令牌对每个用户会话是唯一的。服务器在处理请求时验证令牌的有效性。</p></li><li><p><strong>检查 Referer 和 Origin 头部</strong>: 通过验证 HTTP 请求的 <code>Referer</code> 或 <code>Origin</code> 头部，确保请求是从可信的源发起的。</p></li><li><p><strong>使用 SameSite Cookie 属性</strong>: 设置 Cookie 的 <code>SameSite</code> 属性可以限制 Cookie 在跨站请求中的发送。例如，将 <code>SameSite</code> 设置为 <code>Lax</code> 或 <code>Strict</code> 可以预防 CSRF。</p></li><li><p><strong>双重提交 Cookie</strong>: 另一种方法是将 CSRF 令牌嵌入到用户的 Cookie 中，并且在表单提交时，将此令牌作为请求的一部分发送，服务器会验证 Cookie 和请求中的令牌是否匹配。</p></li><li><p><strong>要求自定义请求头</strong>: 自定义请求头（如 <code>X-Requested-With</code>）不会在普通的网页请求中自动包含，因此可以用来区分正常请求和由第三方网站发起的请求。</p></li><li><p><strong>确保 GET 请求不会改变服务器状态</strong>: 遵循 HTTP 方法的语义，确保 GET 请求不会执行任何数据的改变操作，可以防止一些简单的 CSRF 攻击。</p></li></ol>',9),n=[r];function l(c,i,p,d,F,h){return o(),s("div",null,n)}const f=e(t,[["render",l]]);export{S as __pageData,f as default};
