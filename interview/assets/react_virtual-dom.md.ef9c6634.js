import{_ as s,o as a,c as n,U as l}from"./chunks/framework.8610b7e0.js";const C=JSON.parse('{"title":"虚拟DOM及diff算法","description":"","frontmatter":{},"headers":[],"relativePath":"react/virtual-dom.md","filePath":"react/virtual-dom.md"}'),p={name:"react/virtual-dom.md"},o=l(`<h1 id="虚拟dom及diff算法" tabindex="-1">虚拟DOM及diff算法 <a class="header-anchor" href="#虚拟dom及diff算法" aria-label="Permalink to &quot;虚拟DOM及diff算法&quot;">​</a></h1><p>虚拟 DOM (Virtual DOM) 是一种编程概念，其中 UI 的表示是由虚拟节点或虚拟节点树表示的，而不是直接映射到实际的 DOM。它充当了真实 DOM 和应用状态之间的中介。虚拟 DOM 提供了一种能够在不直接操作 DOM 的情况下更新视图的机制。主要的目标是通过避免直接的 DOM 操作来提高应用的性能，因为直接的 DOM 操作通常比纯 JavaScript 和虚拟 DOM 操作要慢得多。</p><h2 id="虚拟dom-如何工作" tabindex="-1">虚拟DOM 如何工作 <a class="header-anchor" href="#虚拟dom-如何工作" aria-label="Permalink to &quot;虚拟DOM 如何工作&quot;">​</a></h2><ol><li><p><strong>UI 表示</strong>：应用的 UI 被表示为虚拟 DOM 树的结构。</p></li><li><p><strong>修改</strong>：当应用的状态变化时，会生成一个新的虚拟 DOM 树。</p></li><li><p><strong>对比</strong>：新的虚拟 DOM 树与前一个树进行对比，使用一个叫做 &quot;diffing&quot; 的过程。这个过程会确定两棵树之间的具体差异。</p></li><li><p><strong>更新</strong>：一旦知道了差异，就会更新真实的 DOM 来匹配新的虚拟 DOM 树，但只会更新发生变化的部分，而不是重新渲染整个 UI。这种更新方式被称为 &quot;patching&quot;。</p></li></ol><p>这种机制能够帮助提高性能的主要原因：</p><ol><li><p><strong>减少实际 DOM 操作</strong>：直接操作 DOM 通常是缓慢的，尤其是大量的读/写操作时。虚拟 DOM 机制限制了这些操作的数量。</p></li><li><p><strong>批量和延迟的更新</strong>：多个修改可以在虚拟 DOM 中累积，然后一次性更新真实 DOM，而不是为每个小的改变都触发更新。</p></li><li><p><strong>更少的重绘和重流</strong>：浏览器的渲染引擎会尝试优化渲染过程，但频繁的 DOM 更新可能会导致不必要的重绘和重流。通过限制 DOM 更新的数量，虚拟 DOM 可以帮助减少这些操作，从而提高性能。</p></li><li><p><strong>JS 的速度优势</strong>：虚拟 DOM 的 diffing 和 patching 过程完全在 JavaScript 中进行，而 JavaScript 通常比 DOM 操作更快。</p></li></ol><p>虚拟 DOM 不仅仅存在于 React 中（尽管 React 可能是最知名的库，使用了虚拟 DOM），还有其他许多前端库和框架也实现了自己的虚拟 DOM 或类似的概念。</p><h2 id="有了虚拟dom-性能就一定能够得到提升吗" tabindex="-1">有了虚拟DOM，性能就一定能够得到提升吗？ <a class="header-anchor" href="#有了虚拟dom-性能就一定能够得到提升吗" aria-label="Permalink to &quot;有了虚拟DOM，性能就一定能够得到提升吗？&quot;">​</a></h2><p>不一定，虚拟 DOM 并不是性能的银弹。有了虚拟 DOM，性能不一定总是得到提升，而是取决于具体的使用场景和实现方式。以下是一些关于虚拟 DOM 和性能之间关系的要点：</p><ol><li><p><strong>减少真实 DOM 操作</strong>：真实的 DOM 操作通常比 JavaScript 操作更昂贵和更慢。虚拟 DOM 的主要优势在于通过 diffing 算法减少必要的真实 DOM 操作。这意味着，对于大型 UI 更新，使用虚拟 DOM 可能会更快，因为它仅对发生变化的部分进行真实 DOM 更新。</p></li><li><p><strong>额外的开销</strong>：虚拟 DOM 本身引入了一些开销。例如，每次状态变化都需要创建一个新的虚拟 DOM 树，然后与旧的虚拟 DOM 树进行比较。对于非常频繁的小型更新或非常简单的 UI，这种开销可能会使得虚拟 DOM 比直接操作真实 DOM 更慢。</p></li><li><p><strong>优化策略</strong>：虚拟 DOM 实现通常包括一些优化策略，例如应用程序级别的 <code>shouldComponentUpdate</code> 方法或 <code>React.memo</code>，这可以帮助避免不必要的渲染和 diffing。</p></li><li><p><strong>大型列表和动画</strong>：对于大型列表的频繁更新或高帧率的动画，虚拟 DOM 可能不是最佳选择，因为 diffing 过程可能无法在 16ms 内完成（为了实现 60fps 的动画）。在这种情况下，可能需要其他策略或直接使用真实 DOM 操作。</p></li><li><p><strong>初次渲染开销</strong>：虽然虚拟 DOM 可以帮助优化后续的 UI 更新，但初次渲染时，应用程序需要构建初始的虚拟 DOM 树，这可能会稍微慢一些。</p></li></ol><p>总的来说，虚拟 DOM 可以在很多场景中提高性能，特别是当直接的 DOM 操作变得昂贵时。但它并不总是更快，特别是对于小型更新或简单的 UI。如同任何工具或方法，了解其适用的场景和限制是关键。</p><h2 id="react的diff算法与传统的diff算法有什么区别" tabindex="-1">React的diff算法与传统的diff算法有什么区别？ <a class="header-anchor" href="#react的diff算法与传统的diff算法有什么区别" aria-label="Permalink to &quot;React的diff算法与传统的diff算法有什么区别？&quot;">​</a></h2><p>React 的 diff 算法与传统的 diff 算法有一些关键的不同。首先，了解传统的 diff 算法：当我们说“传统的 diff 算法”，我们通常指的是用于比较两个文件（或两段文本）之间差异的算法，例如 Unix 中的 <code>diff</code> 工具。这种算法通常基于最长公共子序列 (LCS) 问题，并且在计算上可能相当昂贵。</p><p>现在，让我们看看 React 的 diff 算法与传统 diff 的不同之处：</p><ol><li><p><strong>目的</strong>：</p><ul><li>传统的 diff 算法：比较两个文本文件或字符串的差异。</li><li>React 的 diff 算法：比较两个虚拟 DOM 结构的差异。</li></ul></li><li><p><strong>效率和优化</strong>：</p><ul><li>传统的 diff 算法：尝试找到最小的差异集，这可能需要 O(n^3) 的时间复杂度。</li><li>React 的 diff 算法：React 采用了一些启发式策略来降低计算复杂度。例如，它假设两个不同类型的元素会产生不同的树，并且开发者不太可能在树的不同层次间改变元素。因此，React 的 diff 通常在实际应用中具有接近线性的性能。</li></ul></li><li><p><strong>深度优先比较</strong>：</p><ul><li>React 的 diff 算法在比较虚拟 DOM 时采用深度优先策略。这意味着它会首先完成一个元素及其所有子元素的比较，然后再转到下一个同级元素。</li></ul></li><li><p><strong>元素类型和键</strong>：</p><ul><li>React 的 diff 算法使用元素的类型和 <code>key</code> 属性作为线索。如果两个元素具有不同的类型，React 会假设它们是完全不同的，并重建整个子树。如果元素是相同类型的，React 会递归地比较它们的子元素。</li></ul></li><li><p><strong>列表的比较</strong>：</p><ul><li>传统的 diff 算法处理列表或数组时，尝试找到最小的差异集，这可能是非常昂贵的。</li><li>React 的 diff 算法利用了 <code>key</code> 属性来识别列表中的元素，这可以使比较过程更加高效。为列表中的每个元素提供稳定、唯一的 <code>key</code> 是优化性能的关键。</li></ul></li></ol><p>虽然 React 的 diff 算法与传统的 diff 算法在目标和方法上有所不同，但它们的核心思想是相似的：找出两个结构之间的差异，并以最有效的方式应用这些差异。但 React 的 diff 算法为特定的任务（即比较虚拟 DOM 结构）进行了优化，因此在实际应用中往往比传统算法更高效。</p><h2 id="react-diff策略有哪些" tabindex="-1">React diff策略有哪些？ <a class="header-anchor" href="#react-diff策略有哪些" aria-label="Permalink to &quot;React diff策略有哪些？&quot;">​</a></h2><p>React 的 diff 算法采用了三种策略来减少 DOM 操作的数量，从而达到提高比较速度和效率的目的。这些策略基于两个基本假设：</p><ol><li>两个不同类型的元素会产生不同的树。</li><li>开发者可以通过 <code>key</code> prop 提供一个稳定的标识来标记在不同渲染间稳定存在的子元素。</li></ol><p>基于这些假设，React 的 diff 算法的策略如下：</p><ol><li><p><strong>tree diff</strong>：</p><ul><li>React 首先比较两棵树的根元素。如果根元素的类型不同，React 将完全销毁旧树并构建新树。例如，<code>&lt;a&gt;</code> 与 <code>&lt;img&gt;</code> 之间的元素类型是不同的，所以 React 会移除 <code>&lt;a&gt;</code> 及其子孙，然后添加 <code>&lt;img&gt;</code>。</li><li>对于自定义组件，如果组件类型不同，则进行整个树的重建。</li></ul></li><li><p><strong>component diff</strong>： 组件比较，React对于组件的策略有两种方式，一种是相同类型的组件和不同类型的组件</p></li></ol><ul><li>对同种类型组件对比，按照层级比较继续比较虚拟DOM树即可，但有种特殊的情况，当组件A如果变化为组件B的时候，有可能虚拟DOM并没有任何变化，所以用户可以通过shouldComponentUpdate() 来判断是否需要更新，判断是否计算</li><li>对于不同组件来说，React会直接判定该组件为dirty component（脏组件），无论结构是否相似，只要判断为脏组件就会直接替换整个组件的所有节点</li></ul><ol start="3"><li><strong>element diff</strong>：</li></ol><ul><li>按元素类型进行比较 React 首先检查两个元素的类型。如果类型不同，React 会删除原来的所有子树，然后用新元素替换整个 DOM 子树。</li></ul><p>例如，当一个元素从 <code>&lt;div&gt;</code> 变为 <code>&lt;span&gt;</code>，React 将会移除 <code>&lt;div&gt;</code> 及其所有子元素，并创建一个新的 <code>&lt;span&gt;</code> 及其子元素。</p><ul><li>按 <code>key</code> 进行比较 当比较同类型的组合组件（比如列表）时，React 依赖 <code>key</code> 属性来区分它们。具有相同 <code>key</code> 的元素会被复用，然后只更新必要的部分。</li></ul><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 旧的 Virtual DOM</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Apple</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Banana</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">3</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Cherry</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 新的 Virtual DOM</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Apple</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">3</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Cherry</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Banana</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>在这个例子中，React 会识别出元素只是进行了位置交换，然后执行相应的 DOM 操作来交换元素，而不是删除和重新创建元素。</p><ul><li>同一类型元素的属性比较 如果两个元素是同一类型的，React 会保留 DOM 节点，并且仅比较和更新有变化的属性。例如，当样式从 <code>{color: &#39;red&#39;}</code> 变为 <code>{color: &#39;green&#39;}</code>，React 只会更新 <code>color</code> 属性，而不会重新创建整个元素。</li></ul><h2 id="它们是如何比较的" tabindex="-1">它们是如何比较的？ <a class="header-anchor" href="#它们是如何比较的" aria-label="Permalink to &quot;它们是如何比较的？&quot;">​</a></h2><ol><li><p><strong>按层级比较</strong></p><p>React只对同一层级元素进行diff。如果一个组件在更新过程中被移动到另一个父节点，React会不复用原来组件，而是重新渲染。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 原结构</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">ComponentA</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 更新后结构</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">ComponentA</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>在上面的例子中，<code>ComponentA</code>即使没有变化，也会被重新渲染。</p></li><li><p><strong>类型相同的节点</strong></p><p>当新旧节点类型相同时，React会保留DOM节点，只更新必要的属性。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 旧</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">old</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 新</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">new</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 结果：仅className会被更新。</span></span></code></pre></div></li><li><p><strong>类型不同的节点</strong></p><p>当元素类型不同时，React会销毁旧节点并创建新节点。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 旧</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 新</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 结果：旧的\`&lt;div&gt;\`将被销毁，新的\`&lt;span&gt;\`将被创建。</span></span></code></pre></div></li><li><p><strong>列表元素的Key</strong></p><p>当渲染列表元素时，应该给每个元素一个唯一的<code>key</code>属性，这样React才能识别和复用它们。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 好的做法</span></span>
<span class="line"><span style="color:#A6ACCD;">items</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;font-style:italic;">item</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">}&gt;{</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 不好的做法</span></span>
<span class="line"><span style="color:#A6ACCD;">items</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">item</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">index</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">}&gt;{</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div></li></ol><h3 id="代码解析" tabindex="-1">代码解析 <a class="header-anchor" href="#代码解析" aria-label="Permalink to &quot;代码解析&quot;">​</a></h3><p>下面是一个简化的diff算法的代码解析：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">diff</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">oldTree</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">newTree</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">patches</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{};</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 存放所有变更</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">walk</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">oldTree</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newTree</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">patches</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">patches</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">walk</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">oldNode</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">newNode</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">index</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">patches</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">currentPatches</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> []</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">newNode</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 节点被删除</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#82AAFF;">isString</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">oldNode</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">isString</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newNode</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 文本节点</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">oldNode</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newNode</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">currentPatches</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">TEXT</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> text</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newNode</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">oldNode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newNode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 节点相同，比较属性</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">attrsPatches</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">diffAttrs</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">oldNode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newNode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">attrsPatches</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">currentPatches</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ATTRS</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> attrs</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">attrsPatches</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 比较子节点</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">diffChildren</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">oldNode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">children</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newNode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">children</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">patches</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 节点不相同，直接替换</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">currentPatches</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">REPLACE</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newNode</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">currentPatches</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">patches</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">currentPatches</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这个简化的代码片段展示了一个非常基础版本的React diff算法，目的是帮助理解其核心逻辑。</p><p>这里的diff算法会递归地遍历旧的Virtual DOM树，并与新的Virtual DOM树进行比较，然后记录下所有的差异（patches）。然后这些差异可以用来更新DOM。</p><h2 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h2><p>React 的 diff 算法具有近似为 O(n) 的时间复杂度。这是相当高效的，特别是与传统的 diff 算法（通常具有 O(n^3) 的时间复杂度）相比。</p><p>这样的性能得益于 React 的几个简化假设：</p><ol><li><p><strong>两个不同类型的元素会生成不同的树</strong>：这意味着如果元素类型改变了，React 不会尝试比较和更新，而是直接卸载旧树并建立一个全新的树。</p></li><li><p><strong>通过 <code>key</code> 属性可以标识稳定的子元素</strong>：这简化了列表中元素的添加、删除和重新排序的复杂性。</p></li></ol><p>因此，在大多数实际应用场景中，React 的这种 &quot;heuristic&quot;（启发式）算法通常足够快，以至于用户无法感觉到任何性能下降。</p><p>需要注意的是，虽然大多数情况下这种算法是有效的，但如果你的应用有特殊的性能需求，还是需要进行具体的性能优化。React DevTools 提供了一种方式来检查组件重新渲染的原因，这有助于你找出可能的性能瓶颈。</p><p>React 的 diff 算法在时间复杂度方面表现得相当不错，这也是它能在复杂 UI 更新中保持高性能的一个重要原因。</p><h2 id="传统的-diff-算法时间复杂度为什么是-o-n-3" tabindex="-1">传统的 diff 算法时间复杂度为什么是 O(n^3) <a class="header-anchor" href="#传统的-diff-算法时间复杂度为什么是-o-n-3" aria-label="Permalink to &quot;传统的 diff 算法时间复杂度为什么是 O(n^3)&quot;">​</a></h2><p>传统的 diff 算法主要用于比较两个序列（例如，两个字符串或两个文件）以找出最小编辑距离。最小编辑距离通常是通过动态规划来解决的，而这样的解法一般具有 O(n^2) 的时间复杂度。</p><p>然而，当应用于树形结构（如 DOM 树或其他层级数据结构）时，寻找两个树之间的最小差异（编辑距离）变得更加复杂。在这种情况下，传统的 diff 算法可能需要对树的每一个节点进行比较，以找出最优的转换方法，这通常具有 O(n^3) 的时间复杂度。</p><p>为什么是 O(n^3)？假设我们有两棵树，每棵树都有 N 个节点。对于第一棵树中的每一个节点，算法都需要去找第二棵树中与之相对应的最佳匹配节点。这一匹配过程本身就是一个求解最小编辑距离的问题，其时间复杂度通常是 O(N^2)。由于我们需要对每一个节点都做这样的操作，所以总体时间复杂度就成了 O(N^3)。</p><p>然而，React 的 diff 算法通过一些启发式方法和假设，将这个复杂度降低到近似 O(n)，这使得其在实际应用中的性能非常出色。</p>`,48),t=[o];function e(c,r,D,F,y,i){return a(),n("div",null,t)}const A=s(p,[["render",e]]);export{C as __pageData,A as default};
