import{_ as a,o as l,c as o,U as t}from"./chunks/framework.8610b7e0.js";const b=JSON.parse('{"title":"JWT","description":"","frontmatter":{},"headers":[],"relativePath":"security/jwt.md","filePath":"security/jwt.md"}'),r={name:"security/jwt.md"},e=t('<h1 id="jwt" tabindex="-1">JWT <a class="header-anchor" href="#jwt" aria-label="Permalink to &quot;JWT&quot;">​</a></h1><h2 id="什么是-jwt" tabindex="-1">什么是 JWT <a class="header-anchor" href="#什么是-jwt" aria-label="Permalink to &quot;什么是 JWT&quot;">​</a></h2><p>JWT（JSON Web Tokens）是一种在网络应用环境间传输信息的紧凑且自包含的方法，主要用于身份验证和信息交换。JWT 的结构使其可以在各种应用中广泛使用，特别是在单页应用（SPA）中。</p><h3 id="结构" tabindex="-1">结构 <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构&quot;">​</a></h3><p>JWT 通常由三部分组成，用点（<code>.</code>）分隔：</p><ol><li><strong>头部（Header）</strong>：包含令牌的类型（通常是 JWT）和所使用的签名算法（如 HMAC SHA256 或 RSA）。</li><li><strong>有效载荷（Payload）</strong>：包含所要传递的数据。这些数据称为声明（Claims），例如用户身份信息、角色、过期时间等。</li><li><strong>签名（Signature）</strong>：对前两部分进行签名，以验证消息在传输过程中未被篡改。</li></ol><h3 id="使用方式" tabindex="-1">使用方式 <a class="header-anchor" href="#使用方式" aria-label="Permalink to &quot;使用方式&quot;">​</a></h3><ul><li><strong>身份验证</strong>：用户登录后，服务器生成一个 JWT 并将其返回给用户。用户随后的每个请求都包含此 JWT，通常在 HTTP 请求的 <code>Authorization</code> 头中承载。</li><li><strong>信息交换</strong>：JWT 可以安全地在各方之间传输信息，因为可以验证其签名。</li></ul><h2 id="为什么使用-jwt" tabindex="-1">为什么使用 JWT <a class="header-anchor" href="#为什么使用-jwt" aria-label="Permalink to &quot;为什么使用 JWT&quot;">​</a></h2><p>使用 JWT（JSON Web Tokens）主要有以下几个原因：</p><h3 id="_1-无状态和可扩展性" tabindex="-1">1. 无状态和可扩展性 <a class="header-anchor" href="#_1-无状态和可扩展性" aria-label="Permalink to &quot;1. 无状态和可扩展性&quot;">​</a></h3><ul><li><strong>无状态认证</strong>：JWT 是无状态的，即不需要在服务器上存储会话信息。这种特性使得 JWT 特别适合分布式系统，其中每个服务都需要独立地验证用户。</li><li><strong>可扩展性</strong>：由于无需在服务器上保存会话状态，扩展应用变得更容易，有助于构建可扩展的应用。</li></ul><h3 id="_2-安全性" tabindex="-1">2. 安全性 <a class="header-anchor" href="#_2-安全性" aria-label="Permalink to &quot;2. 安全性&quot;">​</a></h3><ul><li><strong>数据完整性</strong>：JWT 通过签名保证了数据的完整性，可以防止数据被篡改。</li><li><strong>透明性</strong>：JWT 的内容对用户和开发者都是透明的，可用于调试和透明地处理用户数据。</li></ul><h3 id="_3-跨域和跨服务通信" tabindex="-1">3. 跨域和跨服务通信 <a class="header-anchor" href="#_3-跨域和跨服务通信" aria-label="Permalink to &quot;3. 跨域和跨服务通信&quot;">​</a></h3><ul><li><strong>跨域认证</strong>：JWT 在不同的域之间传递用户身份信息时非常有效，有助于实现单点登录（SSO）等功能。</li><li><strong>微服务架构</strong>：在微服务架构中，服务间需要轻量级的认证机制，JWT 提供了一种方便的方式来在服务之间安全地传递用户身份信息。</li></ul><h3 id="_4-性能" tabindex="-1">4. 性能 <a class="header-anchor" href="#_4-性能" aria-label="Permalink to &quot;4. 性能&quot;">​</a></h3><ul><li><strong>快速处理</strong>：处理 JWT 的过程非常快速，因为它不需要查询数据库来检索会话信息。</li></ul><h3 id="_5-易于使用" tabindex="-1">5. 易于使用 <a class="header-anchor" href="#_5-易于使用" aria-label="Permalink to &quot;5. 易于使用&quot;">​</a></h3><ul><li><strong>广泛的支持</strong>：许多编程语言和框架都支持 JWT，存在大量成熟的库来处理 JWT 的生成和验证。</li><li><strong>与 OAuth2 和 OpenID Connect 兼容</strong>：JWT 是构建现代身份验证和授权机制（如 OAuth 2.0 和 OpenID Connect）的基础。</li></ul><h3 id="_6-自包含" tabindex="-1">6. 自包含 <a class="header-anchor" href="#_6-自包含" aria-label="Permalink to &quot;6. 自包含&quot;">​</a></h3><ul><li><strong>自包含信息</strong>：JWT 包含了所有验证所需的信息，减少了需要多次查询数据库或远程服务的需要。</li></ul><h2 id="安全性" tabindex="-1">安全性 <a class="header-anchor" href="#安全性" aria-label="Permalink to &quot;安全性&quot;">​</a></h2><p>尽管 JWT（JSON Web Tokens）提供了一种方便且灵活的身份验证和信息交换方式，但它也存在一些安全风险和考虑。使用 JWT 时需要注意的主要安全风险：</p><h3 id="_1-窃取和泄露" tabindex="-1">1. 窃取和泄露 <a class="header-anchor" href="#_1-窃取和泄露" aria-label="Permalink to &quot;1. 窃取和泄露&quot;">​</a></h3><ul><li><strong>客户端存储不安全</strong>：JWT 通常存储在客户端（如浏览器的 localStorage）。如果应用受到 XSS（跨站脚本）攻击，攻击者可能会窃取用户的 JWT。</li><li><strong>不安全的传输</strong>：如果不通过 HTTPS 等加密通道传输，JWT 可能会在传输过程中被拦截。</li></ul><h3 id="_2-不恰当的签名和加密" tabindex="-1">2. 不恰当的签名和加密 <a class="header-anchor" href="#_2-不恰当的签名和加密" aria-label="Permalink to &quot;2. 不恰当的签名和加密&quot;">​</a></h3><ul><li><strong>算法弱点</strong>：使用较弱的签名算法（如 HS256）且密钥泄露时，JWT 容易被破解。</li><li><strong>算法篡改</strong>：攻击者可能尝试更改 JWT 的 Header 部分中的算法声明，从而利用服务器配置上的弱点。</li></ul><h3 id="_3-重放攻击" tabindex="-1">3. 重放攻击 <a class="header-anchor" href="#_3-重放攻击" aria-label="Permalink to &quot;3. 重放攻击&quot;">​</a></h3><ul><li><strong>Token 重复使用</strong>：一旦 JWT 被拦截，由于其无状态特性，攻击者可以重复使用这个 Token 进行攻击。</li></ul><h3 id="_4-过期处理" tabindex="-1">4. 过期处理 <a class="header-anchor" href="#_4-过期处理" aria-label="Permalink to &quot;4. 过期处理&quot;">​</a></h3><ul><li><strong>Token 过期管理</strong>：由于 JWT 无法被废除，因此如果 Token 被盗，它将在过期之前一直有效。这要求实现合理的过期策略。</li></ul><h3 id="_5-csrf-攻击" tabindex="-1">5. CSRF 攻击 <a class="header-anchor" href="#_5-csrf-攻击" aria-label="Permalink to &quot;5. CSRF 攻击&quot;">​</a></h3><ul><li><strong>基于 Cookie 的认证</strong>：如果 JWT 存储在 Cookie 中并自动发送，应用可能面临跨站请求伪造（CSRF）的风险。</li></ul><h3 id="_6-无法撤销" tabindex="-1">6. 无法撤销 <a class="header-anchor" href="#_6-无法撤销" aria-label="Permalink to &quot;6. 无法撤销&quot;">​</a></h3><ul><li><strong>撤销问题</strong>：由于 JWT 是自包含的，一旦被签发，就无法从服务器端撤销，除非使用黑名单机制，这可能增加服务器的复杂性和负担。</li></ul><h3 id="_7-敏感信息泄露" tabindex="-1">7. 敏感信息泄露 <a class="header-anchor" href="#_7-敏感信息泄露" aria-label="Permalink to &quot;7. 敏感信息泄露&quot;">​</a></h3><ul><li><strong>Payload 可读性</strong>：JWT 的 Payload 是 Base64 编码的，而不是加密的。这意味着不应在其中存储敏感信息。</li></ul><h3 id="安全最佳实践" tabindex="-1">安全最佳实践 <a class="header-anchor" href="#安全最佳实践" aria-label="Permalink to &quot;安全最佳实践&quot;">​</a></h3><ul><li><strong>使用 HTTPS</strong>：始终通过安全通道传输 JWT。</li><li><strong>强密钥和安全算法</strong>：使用强大的密钥和安全的算法（如 RS256）。</li><li><strong>短期有效性</strong>：设置合理的过期时间。</li><li><strong>不存储敏感信息</strong>：避免在 JWT 中存储敏感数据。</li><li><strong>考虑 Token 刷新机制</strong>：实现 Token 刷新机制，而不是长时间使用同一个 Token。</li><li><strong>防范 XSS 和 CSRF</strong>：采取措施防止 XSS 和 CSRF 攻击。</li></ul><h2 id="传统身份验证-vs-jwt" tabindex="-1">传统身份验证 vs JWT <a class="header-anchor" href="#传统身份验证-vs-jwt" aria-label="Permalink to &quot;传统身份验证 vs JWT&quot;">​</a></h2><p>传统身份验证方法和 JWT（JSON Web Tokens）的使用在多个方面有着显著差异，特别是在处理方式、安全性、可扩展性等方面。以下是两者的对比：</p><h3 id="传统身份验证方法" tabindex="-1">传统身份验证方法 <a class="header-anchor" href="#传统身份验证方法" aria-label="Permalink to &quot;传统身份验证方法&quot;">​</a></h3><p>通常指基于服务器会话的身份验证方式，如会话 Cookies、表单登录等。</p><h4 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h4><ol><li><strong>状态性</strong>：需要在服务器上存储用户会话或状态，如使用会话 Cookies。</li><li><strong>跨域限制</strong>：由于同源策略，Cookie 在跨域场景中受限。</li><li><strong>扩展性问题</strong>：在分布式系统或微服务架构中，维护用户状态需要额外的工作，如会话同步。</li><li><strong>安全性</strong>：更容易受到 CSRF（跨站请求伪造）攻击。如果不使用 HTTPS，Cookie 可能被拦截。</li></ol><h4 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><ul><li>更适合小型应用或不需要考虑大规模分布式部署的场景。</li><li>适用于内部系统或单体架构应用。</li></ul><h3 id="jwt-1" tabindex="-1">JWT <a class="header-anchor" href="#jwt-1" aria-label="Permalink to &quot;JWT&quot;">​</a></h3><p>一种无状态的身份验证方法，通过客户端存储 JWT 来实现。</p><h4 id="特点-1" tabindex="-1">特点 <a class="header-anchor" href="#特点-1" aria-label="Permalink to &quot;特点&quot;">​</a></h4><ol><li><strong>无状态</strong>：不需要在服务器上存储会话信息，每个请求都自包含。</li><li><strong>跨域友好</strong>：由于 JWT 存储在客户端，更适合用于跨域身份验证。</li><li><strong>可扩展性</strong>：适合大规模分布式系统和微服务架构，因为无需同步用户状态。</li><li><strong>安全性考虑</strong>：需要防范 JWT 泄露和窃取（如 XSS 攻击）。不适用于长期会话，因为一旦签发后无法撤销。</li></ol><h4 id="应用场景-1" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景-1" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><ul><li>适用于需要高度可扩展性和跨域支持的现代应用，如单页应用（SPA）。</li><li>适合构建无状态的 RESTful API。</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li>传统身份验证方法由于其状态性和扩展性问题，在现代云计算和微服务架构流行的背景下受到限制。</li><li>JWT 提供了一种更灵活、可扩展的身份验证方式，特别适合于需要跨域支持和无状态架构的应用。</li><li>安全实践不同：在传统方法中需要关注 CSRF 攻击，而在使用 JWT 时，更需注意防止 JWT 泄露和确保传输的安全性。</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://jwt.io/introduction" target="_blank" rel="noreferrer">https://jwt.io/introduction</a></p>',58),i=[e];function n(s,h,d,u,c,g){return l(),o("div",null,i)}const q=a(r,[["render",n]]);export{b as __pageData,q as default};
