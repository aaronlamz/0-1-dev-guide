import{_ as t,o,c as a,U as e}from"./chunks/framework.8610b7e0.js";const u=JSON.parse('{"title":"事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/event-loop.md","filePath":"javascript/event-loop.md"}'),r={name:"javascript/event-loop.md"},i=e('<h1 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h1><h2 id="什么是事件循环" tabindex="-1">什么是事件循环 <a class="header-anchor" href="#什么是事件循环" aria-label="Permalink to &quot;什么是事件循环&quot;">​</a></h2><p>事件循环（Event Loop）是 JavaScript 实现异步编程的一种机制。JavaScript 是单线程的，它只能在一个时间点执行一个任务。当一个任务执行时，它会阻塞后续的任务，直到当前任务执行完成。这就意味着，如果一个任务需要等待一些异步操作（如网络请求、定时器等），那么它将阻塞后续的所有任务。事件循环模型通过允许 JavaScript 引擎在等待异步操作时执行其他任务，有效地解决了这个问题。</p><h2 id="为什么使用事件循环模型" tabindex="-1">为什么使用事件循环模型 <a class="header-anchor" href="#为什么使用事件循环模型" aria-label="Permalink to &quot;为什么使用事件循环模型&quot;">​</a></h2><p>使用事件循环模型的原因主要有以下几点：</p><ol><li><p><strong>单线程：</strong> JavaScript 是单线程的语言，这意味着一次只能执行一项任务。这主要是为了避免复杂的并发问题（例如数据竞态）。然而，这也意味着如果一个任务需要等待一些异步操作（如网络请求、定时器等），那么它将阻塞后续的所有任务。事件循环模型通过允许 JavaScript 引擎在等待异步操作时执行其他任务，有效地解决了这个问题。</p></li><li><p><strong>异步非阻塞：</strong> JavaScript 引擎在等待异步操作完成时并不是处于闲置状态，而是可以处理其他任务。当异步操作完成后，对应的回调函数会被放入任务队列中等待执行，而不会立即打断正在执行的任务。这就是所谓的非阻塞。</p></li><li><p><strong>事件驱动：</strong> 事件循环模型使得 JavaScript 可以响应用户的交互事件（如鼠标点击、键盘输入等）。当一个事件发生时，对应的事件处理函数会被放入任务队列中等待执行。这使得 JavaScript 能够创建丰富的、交互式的网页和应用。</p></li><li><p><strong>有序执行：</strong> 由于 JavaScript 是单线程的，事件循环模型保证了任务的执行顺序。在一个时间点，只有一个任务在执行，其余的任务都在队列中等待。当一个任务完成时，下一个任务开始执行，以此类推。</p></li></ol><p>综上，事件循环模型能够很好地满足 JavaScript 在浏览器环境中的需求，使得 JavaScript 能够创建高性能、响应快、用户体验良好的网页和应用。</p><h2 id="事件循环模型" tabindex="-1">事件循环模型 <a class="header-anchor" href="#事件循环模型" aria-label="Permalink to &quot;事件循环模型&quot;">​</a></h2><ol><li><p><strong>初始化阶段</strong>：当一个 HTML 页面在浏览器中加载时，浏览器首先会解析 HTML 文档，然后创建一个全局的执行环境，这是一个宏任务。JavaScript 引擎会在这个全局执行环境中运行，执行所有的全局同步代码。</p></li><li><p><strong>宏任务（MacroTask）</strong>：在全局代码运行完成后，JavaScript 引擎会查看宏任务队列是否有任务需要执行。宏任务包括用户交互事件、网络请求、定时器等。这些任务是由 Web API 提供并由 JavaScript 引擎调用。每次从宏任务队列中取出一个任务执行，都会为这个任务创建一个新的执行环境。JavaScript 引擎会在这个新的执行环境中运行任务的代码。</p></li><li><p><strong>微任务（MicroTask）</strong>：当一个宏任务执行完成后，JavaScript 引擎会查看微任务队列是否有任务需要执行。微任务包括 Promise 的回调函数、MutationObserver 的回调函数等。这些任务是由 JavaScript 本身提供。和宏任务不同，所有的微任务都会在同一个执行环境中运行，直到微任务队列被清空。也就是说，一旦开始处理微任务，就会一直处理到队列为空，而不会在执行微任务的过程中插入宏任务或渲染。</p></li><li><p><strong>渲染</strong>：当微任务队列被清空后，浏览器会查看是否需要渲染。渲染通常包括计算 CSS 属性、布局、绘制等步骤。注意，浏览器不会在每个任务之后都进行渲染，而是在一定条件下才会渲染，例如改变了 DOM 结构或样式、或者满足了 requestAnimationFrame 的调用条件等。</p></li><li><p><strong>循环</strong>：渲染完成后，JavaScript 引擎会回到宏任务队列，开始下一个宏任务的处理。这个过程会一直重复，形成一个事件循环。</p></li></ol><p>通过以上步骤，浏览器实现了 JavaScript 的并发模型，并通过事件循环机制处理了异步任务，使得 JavaScript 代码可以在等待异步结果返回时执行其他任务，从而提高了代码的执行效率。</p><h2 id="宏任务和微任务" tabindex="-1">宏任务和微任务 <a class="header-anchor" href="#宏任务和微任务" aria-label="Permalink to &quot;宏任务和微任务&quot;">​</a></h2><p>在 JavaScript 的事件循环模型中，任务和微任务是两种重要的概念。它们都代表待执行的工作单元，但是它们的处理方式和优先级有所不同。</p><p><strong>任务（Task）：</strong> 也称为宏任务（MacroTask）。包括：整个脚本（Script），setTimeout，setInterval，setImmediate，I/O，UI 渲染等。当浏览器启动事件循环时，它会从任务队列中取出一个任务并执行，执行完之后则会进行下一轮的事件循环。</p><p><strong>微任务（MicroTask）：</strong> 包括：Promise.then/catch/finally，process.nextTick，MutationObserver等。微任务的执行时机是在当前任务执行结束后，下一个任务开始之前。在这个过程中，会执行所有的微任务。只要微任务队列不为空，就会一直执行，直到队列为空，再执行下一个宏任务。</p><p>两者的主要区别在于它们的执行时机：</p><ul><li><p>对于任务来说，浏览器会为每一个任务分配一个新的任务队列，任务在队列中一次只能执行一个，执行完一个任务后，浏览器会在下一个事件循环中执行下一个任务。</p></li><li><p>对于微任务来说，它们通常来自任务的内部，例如，一个任务中可能会生成多个微任务。在当前任务执行完毕后，浏览器会立即执行所有的微任务，然后再进行下一个事件循环。</p></li></ul><p>总结起来，微任务的优先级高于任务，微任务会在每个任务之间执行。而任务则是构成 JavaScript 异步操作的基本单位，它们在事件循环中一次只能执行一个，执行完一个任务后，浏览器会在下一个事件循环中执行下一个任务。</p><h2 id="node-js-中的事件循环" tabindex="-1">Node.js 中的事件循环 <a class="header-anchor" href="#node-js-中的事件循环" aria-label="Permalink to &quot;Node.js 中的事件循环&quot;">​</a></h2><p>Node.js 中的事件循环是其非阻塞 I/O 操作的核心，使其可以处理高并发。下面是 Node.js 事件循环的一些核心概念和工作过程：</p><ol><li><p><strong>Libuv 库</strong>: Node.js 使用 libuv 库来实现其事件循环机制。libuv 还提供了跨平台的抽象，使得 Node.js 可以在不同操作系统上运行。</p></li><li><p><strong>Phases of the Event Loop</strong>: 事件循环的不同阶段处理不同类型的任务。下面是主要的阶段：</p><ul><li><strong>timers</strong>: 执行已到期的 <code>setTimeout</code> 和 <code>setInterval</code> 的回调函数。</li><li><strong>pending callbacks</strong>: 执行延迟到下一个循环迭代的 I/O 回调。</li><li><strong>idle, prepare</strong>: 仅供 libuv 内部使用。</li><li><strong>poll</strong>: 检索新的 I/O 操作，执行与 I/O 相关的回调。</li><li><strong>check</strong>: 执行 <code>setImmediate()</code> 的回调。</li><li><strong>close callbacks</strong>: 执行关闭请求的 <code>close</code> 事件回调。</li></ul></li><li><p><strong>Process.nextTick</strong>: 除了这些阶段，Node.js 还有一个名为 <code>process.nextTick</code> 的特殊机制。任何传递给 <code>process.nextTick</code> 的回调函数将会在当前阶段完成后、下一阶段开始前被调用。</p></li><li><p><strong>非阻塞 I/O</strong>: 由于 Node.js 使用非阻塞 I/O，所以即使文件读取或网络请求耗时，其他操作仍可以继续。当操作完成时，回调函数被推入事件循环相应的阶段等待执行。</p></li><li><p><strong>Microtasks</strong>: 在每个阶段完成后，如果有的话，微任务队列将被处理。这包括 Promise 回调等。</p></li><li><p><strong>Error Handling</strong>: 如果在事件循环过程中抛出异常并且没有捕获，它通常会触发 <code>uncaughtException</code> 事件。如果没有为该事件注册处理程序，进程将退出。</p></li><li><p><strong>Shutdown Phase</strong>: 一旦回调队列为空，且没有额外的工作被添加，Node.js 将清理任何剩余的定时器并干净地关闭。</p></li></ol><p>这种事件驱动的架构使 Node.js 能够在单个线程上高效地处理许多并发连接，这是 Node.js 在构建高并发、I/O 密集型应用程序方面的关键优势。</p>',21),s=[i];function l(n,p,c,d,g,h){return o(),a("div",null,s)}const S=t(r,[["render",l]]);export{u as __pageData,S as default};
