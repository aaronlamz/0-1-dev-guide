import{_ as o,o as e,c as a,U as t}from"./chunks/framework.8610b7e0.js";const u=JSON.parse('{"title":"HTTP 缓存","description":"","frontmatter":{},"headers":[],"relativePath":"network/http-cache.md","filePath":"network/http-cache.md"}'),i={name:"network/http-cache.md"},r=t('<h1 id="http-缓存" tabindex="-1">HTTP 缓存 <a class="header-anchor" href="#http-缓存" aria-label="Permalink to &quot;HTTP 缓存&quot;">​</a></h1><p>HTTP 缓存是一种重要的机制，用于减少网络延迟，提高网站性能，并减轻服务器的负担。HTTP 缓存可以在不同的级别上实现，如浏览器缓存、代理服务器缓存或 CDN 缓存。下面是关于 HTTP 缓存的一些关键概念和策略：</p><h2 id="缓存类型" tabindex="-1">缓存类型 <a class="header-anchor" href="#缓存类型" aria-label="Permalink to &quot;缓存类型&quot;">​</a></h2><ol><li><strong>强缓存（Strong Cache）</strong>：浏览器不会向服务器发送请求，直接从本地缓存读取资源。控制强缓存的主要方式是 HTTP 响应头中的 <code>Cache-Control</code> 和 <code>Expires</code> 字段。</li><li><strong>协商缓存（Negotiated Cache）</strong>：浏览器会向服务器发送请求，询问缓存资源是否更新。这主要通过 <code>Last-Modified/If-Modified-Since</code> 和 <code>ETag/If-None-Match</code> 头部实现。</li></ol><h2 id="http-头部" tabindex="-1">HTTP 头部 <a class="header-anchor" href="#http-头部" aria-label="Permalink to &quot;HTTP 头部&quot;">​</a></h2><ul><li><strong>Cache-Control</strong>：控制资源的缓存逻辑，如 <code>max-age</code> 指定资源的最大有效时间。</li><li><strong>Expires</strong>：指定资源的到期时间，现在通常被 <code>Cache-Control</code> 的 <code>max-age</code> 指令替代。</li><li><strong>Last-Modified/If-Modified-Since</strong>：基于时间的验证机制，用于协商缓存。</li><li><strong>ETag/If-None-Match</strong>：基于标识符的验证机制，更加精确，也用于协商缓存。</li></ul><h2 id="缓存流程" tabindex="-1">缓存流程 <a class="header-anchor" href="#缓存流程" aria-label="Permalink to &quot;缓存流程&quot;">​</a></h2><ol><li><strong>浏览器请求资源</strong>：浏览器请求一个网页资源。</li><li><strong>检查强缓存</strong>：浏览器检查本地缓存中是否有该资源的副本，以及该副本是否仍然有效（基于 <code>Cache-Control</code> 或 <code>Expires</code>）。</li><li><strong>如果强缓存有效</strong>：直接使用本地缓存。</li><li><strong>如果强缓存无效</strong>：浏览器向服务器发送请求，携带 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> 头部。</li><li><strong>服务器检查资源是否更新</strong>：服务器检查资源是否自上次请求以来有所修改。</li><li><strong>如果资源未修改（304 Not Modified）</strong>：浏览器使用本地缓存。</li><li><strong>如果资源已修改（200 OK）</strong>：服务器发送新资源，浏览器缓存并展示。</li></ol><h2 id="缓存策略" tabindex="-1">缓存策略 <a class="header-anchor" href="#缓存策略" aria-label="Permalink to &quot;缓存策略&quot;">​</a></h2><ul><li><strong>为不同资源设置不同缓存策略</strong>：通常静态资源（如图片、CSS、JS 文件）可以设置较长时间的缓存，而动态内容则需要更短的缓存时间或不缓存。</li><li><strong>版本控制</strong>：对文件进行版本控制（如通过文件名或查询字符串），以便在文件更新时立即获取新版本。</li></ul><h2 id="为什么使用缓存" tabindex="-1">为什么使用缓存 <a class="header-anchor" href="#为什么使用缓存" aria-label="Permalink to &quot;为什么使用缓存&quot;">​</a></h2><ul><li><strong>减少延迟</strong>：减少了由于网络传输带来的延迟。</li><li><strong>减轻服务器负担</strong>：减少了服务器处理请求的次数。</li><li><strong>提高性能</strong>：用户体验更佳，因为网页加载更快。</li></ul><h2 id="缓存策略完整过程" tabindex="-1">缓存策略完整过程 <a class="header-anchor" href="#缓存策略完整过程" aria-label="Permalink to &quot;缓存策略完整过程&quot;">​</a></h2><p>HTTP 缓存策略的详细过程描述可以分为几个关键步骤，这些步骤涉及如何确定资源是否可以从缓存中获取，以及何时需要从服务器重新请求资源。这个过程主要依赖于 HTTP 头部字段来控制，这些字段定义了资源的缓存规则。</p><h3 id="步骤-1-浏览器请求资源" tabindex="-1">步骤 1: 浏览器请求资源 <a class="header-anchor" href="#步骤-1-浏览器请求资源" aria-label="Permalink to &quot;步骤 1: 浏览器请求资源&quot;">​</a></h3><p>当用户访问一个网页时，浏览器会为网页上的每个资源（如 HTML 页面、CSS 样式表、JavaScript 文件、图片等）发起 HTTP 请求。</p><h3 id="步骤-2-检查强缓存" tabindex="-1">步骤 2: 检查强缓存 <a class="header-anchor" href="#步骤-2-检查强缓存" aria-label="Permalink to &quot;步骤 2: 检查强缓存&quot;">​</a></h3><p>浏览器首先检查本地缓存（如果有的话），并查看缓存条目是否还有效。</p><ul><li><strong>Cache-Control</strong>: 最常用的缓存控制头，指定资源可以被缓存多长时间。例如，<code>Cache-Control: max-age=3600</code> 指示资源在 3600 秒（1小时）内有效。</li><li><strong>Expires</strong>: 这是一个较老的字段，它设置了资源的绝对过期时间。如果同时存在 <code>Cache-Control</code> 和 <code>Expires</code>，前者优先级更高。</li></ul><p>如果根据这些头部字段判断缓存的资源仍然有效（未过期），浏览器将直接使用缓存的资源，不会向服务器发送请求。</p><h3 id="步骤-3-检查协商缓存" tabindex="-1">步骤 3: 检查协商缓存 <a class="header-anchor" href="#步骤-3-检查协商缓存" aria-label="Permalink to &quot;步骤 3: 检查协商缓存&quot;">​</a></h3><p>如果强缓存无效（缓存已过期或不存在），浏览器会发送 HTTP 请求到服务器，请求中包含某些特定的头部字段来检查资源是否被修改。</p><ul><li><strong>Last-Modified/If-Modified-Since</strong>: <code>Last-Modified</code> 是服务器响应中的头部字段，表示资源最后修改的时间。在随后的请求中，浏览器会发送 <code>If-Modified-Since</code>，其值为之前的 <code>Last-Modified</code> 值。如果服务器判断内容自该时间以来未更改，则返回 <code>304 Not Modified</code> 响应，指示浏览器可以使用缓存的资源。</li><li><strong>ETag/If-None-Match</strong>: <code>ETag</code> 是资源的特定标识符。类似于 <code>Last-Modified</code> 机制，<code>ETag</code> 在服务器响应中返回，而 <code>If-None-Match</code> 在随后的请求中发送。如果 <code>ETag</code> 未改变，服务器同样会返回 <code>304 Not Modified</code>。</li></ul><h3 id="步骤-4-服务器响应" tabindex="-1">步骤 4: 服务器响应 <a class="header-anchor" href="#步骤-4-服务器响应" aria-label="Permalink to &quot;步骤 4: 服务器响应&quot;">​</a></h3><p>基于浏览器的请求和缓存验证头部字段，服务器决定如何响应。</p><ul><li><strong>资源未修改（304 Not Modified）</strong>：如果资源自上次请求以来未更改，服务器会返回 <code>304 Not Modified</code> 状态码，浏览器将使用缓存的资源。</li><li><strong>资源已修改（200 OK）</strong>：如果资源已更改，服务器会发送 <code>200 OK</code> 响应，连同新的资源和更新的缓存控制头部。</li></ul><h3 id="步骤-5-更新缓存" tabindex="-1">步骤 5: 更新缓存 <a class="header-anchor" href="#步骤-5-更新缓存" aria-label="Permalink to &quot;步骤 5: 更新缓存&quot;">​</a></h3><p>在接收到新的资源后，浏览器会更新本地缓存，以备下次使用。</p>',28),d=[r];function l(n,c,s,h,g,f){return e(),a("div",null,d)}const T=o(i,[["render",l]]);export{u as __pageData,T as default};
