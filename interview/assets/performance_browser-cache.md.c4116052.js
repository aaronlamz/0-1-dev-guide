import{_ as o,o as e,c as t,U as r}from"./chunks/framework.8610b7e0.js";const _=JSON.parse('{"title":"详细说说浏览器的缓存策略","description":"","frontmatter":{},"headers":[],"relativePath":"performance/browser-cache.md","filePath":"performance/browser-cache.md"}'),s={name:"performance/browser-cache.md"},i=r('<h1 id="详细说说浏览器的缓存策略" tabindex="-1">详细说说浏览器的缓存策略 <a class="header-anchor" href="#详细说说浏览器的缓存策略" aria-label="Permalink to &quot;详细说说浏览器的缓存策略&quot;">​</a></h1><p>浏览器缓存策略是优化网站性能和响应时间的关键部分。以下是关于浏览器缓存策略的详细说明：</p><ol><li><p><strong>强缓存</strong>:</p><ul><li><strong>Expires</strong>: HTTP/1.0 的遗留。设置一个未来的绝对时间作为资源的过期时间。但由于客户端和服务器的时间可能会有偏差，这种方式逐渐被替代。</li><li><strong>Cache-Control</strong>: <ul><li><strong>max-age=[seconds]</strong>: 资源会在指定的秒数后过期。</li><li><strong>s-maxage=[seconds]</strong>: 只对代理服务器生效，如CDN。</li><li><strong>public</strong>: 可以被所有用户缓存（即用户、CDN、代理服务器都可以缓存）。</li><li><strong>private</strong>: 只能被终端浏览器缓存。</li><li><strong>no-store</strong>: 不允许缓存该资源。</li><li><strong>no-cache</strong>: 需要向服务器验证缓存是否还有效。</li></ul></li></ul></li><li><p><strong>协商缓存</strong>:</p><ul><li><strong>Last-Modified / If-Modified-Since</strong>: 服务器通过 <code>Last-Modified</code> 响应头指明资源最后的修改日期。浏览器再次请求资源时会带上 <code>If-Modified-Since</code> 请求头，值为上次响应的 <code>Last-Modified</code>。如果资源未修改，服务器返回 <code>304 Not Modified</code>；如果已修改，返回新资源和 <code>200 OK</code>。</li><li><strong>ETag / If-None-Match</strong>: 服务器为资源生成一个唯一标识 <code>ETag</code>。浏览器在再次请求时携带 <code>If-None-Match</code> 请求头，其值为上次响应的 <code>ETag</code>。服务器根据是否匹配来判断资源是否被修改。</li></ul></li><li><p><strong>其他相关头</strong>:</p><ul><li><strong>Pragma</strong>: HTTP/1.0 的遗留，与 <code>Cache-Control: no-cache</code> 类似。</li><li><strong>Vary</strong>: 确定哪些请求头的值可能会导致不同的响应。例如，<code>Vary: Accept-Encoding</code> 表示响应依赖于 <code>Accept-Encoding</code> 请求头的值。</li></ul></li><li><p><strong>预加载与预读取</strong>:</p><ul><li><strong>Preload</strong>: 提前加载资源。例如，<code>&lt;link rel=&quot;preload&quot; as=&quot;script&quot; href=&quot;script.js&quot;&gt;</code>。</li><li><strong>Prefetch</strong>: 提前获取将来可能需要的资源。例如，<code>&lt;link rel=&quot;prefetch&quot; href=&quot;page2.html&quot;&gt;</code>。</li></ul></li><li><p><strong>Service Workers</strong>: 是运行在浏览器背景的脚本，允许开发者自定义资源的缓存逻辑，拦截和修改网络请求。这可以用于创建复杂的缓存策略或实现离线功能。</p></li><li><p><strong>Application Cache (已废弃)</strong>: 早期用于实现离线Web应用的技术。由于有很多问题和限制，现在已被 Service Workers 替代。</p></li><li><p><strong>Memory Cache vs Disk Cache</strong>: 浏览器首先会检查内存中是否有缓存的资源（这是最快的）。如果内存中没有，则会检查硬盘中是否有缓存的资源。</p></li><li><p><strong>推送（HTTP/2 Push）</strong>: 允许服务器未经请求就发送资源到客户端，预测客户端可能会需要的资源。</p></li></ol><p>为了获得最佳的性能和用户体验，建议使用组合策略，考虑资源的更新频率、大小和重要性。使用工具如 Lighthouse 或 webpagetest.org 可以帮助你了解和优化你的缓存策略。</p>',4),c=[i];function n(l,a,d,g,p,h){return e(),t("div",null,c)}const f=o(s,[["render",n]]);export{_ as __pageData,f as default};
