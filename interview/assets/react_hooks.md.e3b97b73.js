import{_ as s,o as a,c as n,U as o}from"./chunks/framework.8610b7e0.js";const A=JSON.parse('{"title":"Hooks 是什么？它解决了什么问题？","description":"","frontmatter":{},"headers":[],"relativePath":"react/hooks.md","filePath":"react/hooks.md"}'),l={name:"react/hooks.md"},e=o(`<h1 id="hooks-是什么-它解决了什么问题" tabindex="-1">Hooks 是什么？它解决了什么问题？ <a class="header-anchor" href="#hooks-是什么-它解决了什么问题" aria-label="Permalink to &quot;Hooks 是什么？它解决了什么问题？&quot;">​</a></h1><h2 id="什么是-hooks" tabindex="-1">什么是 Hooks？ <a class="header-anchor" href="#什么是-hooks" aria-label="Permalink to &quot;什么是 Hooks？&quot;">​</a></h2><p>Hooks 是 React 16.8 版本引入的一个新特性，它允许你在不编写 class 的情况下使用 state 和其他 React 特性。Hooks 是一些可让你在函数组件里“钩入” React state 及生命周期等特性的函数。</p><h2 id="主要的-react-hooks" tabindex="-1">主要的 React Hooks： <a class="header-anchor" href="#主要的-react-hooks" aria-label="Permalink to &quot;主要的 React Hooks：&quot;">​</a></h2><ul><li><code>useState</code>: 用于添加本地状态管理。</li><li><code>useEffect</code>: 用于执行副作用，如 API 调用、订阅等。</li><li><code>useContext</code>: 用于访问 React Context。</li><li><code>useReducer</code>: 类似 <code>useState</code> 但用于更复杂的状态逻辑。</li><li><code>useMemo</code> 和 <code>useCallback</code>: 用于优化性能。</li><li><code>useRef</code>: 用于访问 DOM 元素。</li><li>自定义 Hooks: 组合以上 Hooks 来创建复用的逻辑。</li></ul><h2 id="它解决了什么问题" tabindex="-1">它解决了什么问题？ <a class="header-anchor" href="#它解决了什么问题" aria-label="Permalink to &quot;它解决了什么问题？&quot;">​</a></h2><ol><li><p><strong>复用状态逻辑</strong>: 在 class 组件中，状态逻辑复用通常比较困难，需要用到 render props、高阶组件或者 <code>this.setState</code> 中复杂的逻辑。Hooks 使得状态逻辑易于复用和测试。</p></li><li><p><strong>组件复杂性</strong>: 随着逻辑增长，class 组件变得难以理解。Hooks 允许你在更小、更易于管理的函数组件中分离关注点。</p></li><li><p><strong>强制函数式编程</strong>: Hooks 鼓励使用函数式编程模式，使代码更简洁、更易于推理。</p></li><li><p><strong>更好的整合</strong>: <code>useEffect</code> Hook 使你能更好地组织副作用和其他外部组件交互的代码。</p></li><li><p><strong>简化生命周期事件</strong>: 在 class 组件中，生命周期方法（如 <code>componentDidMount</code>, <code>componentDidUpdate</code>）往往包含不相关的逻辑。Hooks（如 <code>useEffect</code>）允许你根据相关性将代码组织在一起。</p></li><li><p><strong>更易于使用的 API</strong>: Hooks API 通常更易于理解和使用，尤其是对于新手和非专职的前端开发者。</p></li></ol><p>总体来说，Hooks 提供了一种更易于管理和重用状态逻辑的方式，同时也简化了组件代码，使其更易于测试和维护。</p><h2 id="主要的-react-hooks-实现原理" tabindex="-1">主要的 React Hooks 实现原理 <a class="header-anchor" href="#主要的-react-hooks-实现原理" aria-label="Permalink to &quot;主要的 React Hooks 实现原理&quot;">​</a></h2><h3 id="usestate" tabindex="-1">useState <a class="header-anchor" href="#usestate" aria-label="Permalink to &quot;useState&quot;">​</a></h3><ol><li><p><strong>状态存储</strong>: 在 React 的内部，每个组件实例有一个与之关联的 &quot;fiber&quot; 对象。这个 fiber 对象存储了组件的状态和其他信息。</p></li><li><p><strong>渲染顺序</strong>: React 依赖于组件调用 <code>useState</code> 的顺序不变来正确地追踪状态。这也是为什么 Hooks 不能在条件语句或循环内部使用。</p></li><li><p><strong>初始化</strong>: 当组件首次渲染时，<code>useState</code> 会用你提供的初始值来创建一个新的状态变量。</p></li><li><p><strong>更新</strong>: 在后续渲染中，<code>useState</code> 会返回当前的状态值。如果你调用了 setter 函数（<code>useState</code> 返回的第二个值），React 会重新渲染组件，并使用新的状态值。</p></li></ol><p>要实现一个简化版本的 <code>useState</code>，你需要考虑以下关键要点：</p><ol><li>创建一个状态队列，用于存储组件的状态。</li><li>提供 <code>useState</code> 函数，它会返回当前状态值和状态更新函数。</li><li>在组件渲染时，使用状态队列中的状态值。</li></ol><p>下面是一个基本的示例，演示如何手动实现一个简化的 <code>useState</code>：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> stateQueue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 状态队列</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">initialValue</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 检查是否有已保存的状态</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">savedState</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">stateQueue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">shift</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 如果有，返回保存的状态</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">savedState</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">savedState</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 否则，创建一个新的状态</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">initialValue</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 创建状态更新函数</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setState</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">newValue</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 更新状态</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">stateQueue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newValue</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 触发重新渲染</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">render</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 返回当前状态和状态更新函数</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> [</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setState</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 模拟组件渲染</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">render</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setCount</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Count: </span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">}\`</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 模拟用户交互</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">setCount</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 更新状态</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 第一次渲染</span></span>
<span class="line"><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>这是一个非常基本的示例，用于演示 <code>useState</code> 的基本原理。在实际的 React 源代码中，实现要复杂得多，还要处理更多的情况，例如多个状态的管理和状态的合并。</p><h3 id="useeffect" tabindex="-1">useEffect <a class="header-anchor" href="#useeffect" aria-label="Permalink to &quot;useEffect&quot;">​</a></h3><h4 id="useeffect-使用场景" tabindex="-1">useEffect 使用场景 <a class="header-anchor" href="#useeffect-使用场景" aria-label="Permalink to &quot;useEffect 使用场景&quot;">​</a></h4><p><code>useEffect</code> 是 React Hooks 中的一个核心 Hook，它提供了在函数组件中处理副作用的能力。以下是一些常见的 <code>useEffect</code> 使用场景：</p><ol><li><strong>数据获取</strong>: 例如，从 API 中获取数据并将其设置为组件状态。</li><li><strong>手动的 DOM 操作</strong>: 例如，聚焦一个输入框或与第三方库的 DOM 操作。</li><li><strong>订阅与取消订阅</strong>: 如 WebSockets、EventSource 或其他事件监听器。</li><li><strong>启动和清理计时器</strong>.</li><li><strong>性能测量和日志记录</strong>.</li><li><strong>其他副作用</strong>: 例如，更改全局变量、使用 local storage 或调用外部函数。</li></ol><h3 id="useeffect-使用方式" tabindex="-1">useEffect 使用方式 <a class="header-anchor" href="#useeffect-使用方式" aria-label="Permalink to &quot;useEffect 使用方式&quot;">​</a></h3><p><code>useEffect</code> 接受两个参数：一个是包含你希望执行的副作用的函数，另一个是依赖数组。</p><ul><li>如果不提供依赖数组，副作用函数将在每次渲染后都执行。</li><li>如果提供了一个空的依赖数组 (<code>[]</code>)，副作用函数只会在组件挂载和卸载时执行一次。</li><li>如果提供了一个具有值的依赖数组，那么只有当依赖中的任何值发生更改时，副作用函数才会执行。</li></ul><h3 id="useeffect-实现原理" tabindex="-1">useEffect 实现原理 <a class="header-anchor" href="#useeffect-实现原理" aria-label="Permalink to &quot;useEffect 实现原理&quot;">​</a></h3><p>要理解 <code>useEffect</code> 的实现原理，我们需要深入了解 React 的工作方式和 Hooks 的原理。简化版的实现原理如下：</p><ol><li><p><strong>渲染和记忆</strong>: 当组件渲染时，React 会跟踪使用的所有 hooks（如 <code>useState</code>、<code>useEffect</code>）。这是通过一个内部的“hooks数组”实现的，其中每个 hook 都有一个对应的位置。</p></li><li><p><strong>调度副作用</strong>: 在组件渲染完成后，React 将所有注册的 <code>useEffect</code> callbacks 放入一个队列中。当浏览器准备进行下一次绘制（如使用 <code>requestAnimationFrame</code>）之前，React 将开始运行这些副作用函数。</p></li><li><p><strong>清理和再次调用</strong>: 如果 <code>useEffect</code> 返回了一个清理函数，React 会在下次运行同一副作用之前或组件卸载时调用它，以确保资源得到清理。</p></li><li><p><strong>依赖性检查</strong>: 为了确定是否需要重新运行副作用，React 会比较当前渲染中的依赖数组与上一次的数组。如果任何依赖项发生了更改，React 就会重新运行副作用。</p></li><li><p><strong>确保顺序</strong>: React 保证 hooks 的执行顺序与它们在组件中的声明顺序相匹配，这样就可以确保状态和副作用始终是同步的，并且有正确的依赖信息。</p></li></ol><p>实现一个简化版的 <code>useEffect</code> 是一个相当复杂的任务，因为真实的 React 中的 <code>useEffect</code> 与调度、渲染和 React 内部的其他部分紧密集成。但我可以为你提供一个简化的版本，来帮助理解其基本思想。</p><p>假设我们有以下的假设：</p><ol><li>我们只考虑执行一次的 <code>useEffect</code>（即传入空的依赖数组 <code>[]</code>）。</li><li>我们假设这只在一个组件中工作，而不是在完整的应用中。</li><li>清除副作用是必要的。</li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> hasRun </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">// 标志是否已经运行过副作用</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> cleanupFunction </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 清除函数</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useEffect</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">callback</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">hasRun</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">cleanupFunction</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">callback</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">hasRun</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 当组件被卸载时的处理（这是一个简化的版本，实际上不会这样做）</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">beforeunload</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">cleanupFunction</span><span style="color:#F07178;">) </span><span style="color:#82AAFF;">cleanupFunction</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 示例使用</span></span>
<span class="line"><span style="color:#82AAFF;">useEffect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Side effect has run.</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Cleanup function called.</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>这是一个非常简化的版本，并没有考虑许多复杂的情况，如依赖数组的更改、多个组件的情况、优化的调度等等。</p><p>实际的 <code>useEffect</code> 实现会涉及 React 的调度机制、hooks 的内部管理、批处理、协调等等。但希望上面的示例能帮助你理解 <code>useEffect</code> 的基本思想。</p><h3 id="usecontext" tabindex="-1">useContext <a class="header-anchor" href="#usecontext" aria-label="Permalink to &quot;useContext&quot;">​</a></h3><ol><li><p><strong>React Context</strong>: <code>useContext</code> 是对 React 的 <code>Context</code> API 的封装。它使组件能够直接访问最近的 <code>Context.Provider</code> 的值。</p></li><li><p><strong>订阅模型</strong>: 内部实现通常涉及将组件订阅到 <code>Context</code> 的更改，以便在 <code>Context</code> 值更改时重新渲染组件。</p></li></ol><h3 id="自定义-hooks" tabindex="-1">自定义 Hooks <a class="header-anchor" href="#自定义-hooks" aria-label="Permalink to &quot;自定义 Hooks&quot;">​</a></h3><p>自定义 Hooks 本质上是一种模式，它允许你通过组合其他 Hooks 来封装和共享组件逻辑。</p>`,36),p=[e];function t(c,r,F,y,i,D){return a(),n("div",null,p)}const u=s(l,[["render",t]]);export{A as __pageData,u as default};
