# 虚拟DOM及diff算法

虚拟 DOM (Virtual DOM) 是一种编程概念，其中 UI 的表示是由虚拟节点或虚拟节点树表示的，而不是直接映射到实际的 DOM。它充当了真实 DOM 和应用状态之间的中介。虚拟 DOM 提供了一种能够在不直接操作 DOM 的情况下更新视图的机制。主要的目标是通过避免直接的 DOM 操作来提高应用的性能，因为直接的 DOM 操作通常比纯 JavaScript 和虚拟 DOM 操作要慢得多。


## 虚拟DOM 如何工作

1. **UI 表示**：应用的 UI 被表示为虚拟 DOM 树的结构。

2. **修改**：当应用的状态变化时，会生成一个新的虚拟 DOM 树。

3. **对比**：新的虚拟 DOM 树与前一个树进行对比，使用一个叫做 "diffing" 的过程。这个过程会确定两棵树之间的具体差异。

4. **更新**：一旦知道了差异，就会更新真实的 DOM 来匹配新的虚拟 DOM 树，但只会更新发生变化的部分，而不是重新渲染整个 UI。这种更新方式被称为 "patching"。

这种机制能够帮助提高性能的主要原因：

1. **减少实际 DOM 操作**：直接操作 DOM 通常是缓慢的，尤其是大量的读/写操作时。虚拟 DOM 机制限制了这些操作的数量。

2. **批量和延迟的更新**：多个修改可以在虚拟 DOM 中累积，然后一次性更新真实 DOM，而不是为每个小的改变都触发更新。

3. **更少的重绘和重流**：浏览器的渲染引擎会尝试优化渲染过程，但频繁的 DOM 更新可能会导致不必要的重绘和重流。通过限制 DOM 更新的数量，虚拟 DOM 可以帮助减少这些操作，从而提高性能。

4. **JS 的速度优势**：虚拟 DOM 的 diffing 和 patching 过程完全在 JavaScript 中进行，而 JavaScript 通常比 DOM 操作更快。

虚拟 DOM 不仅仅存在于 React 中（尽管 React 可能是最知名的库，使用了虚拟 DOM），还有其他许多前端库和框架也实现了自己的虚拟 DOM 或类似的概念。

## 有了虚拟DOM，性能就一定能够得到提升吗？

不一定，虚拟 DOM 并不是性能的银弹。有了虚拟 DOM，性能不一定总是得到提升，而是取决于具体的使用场景和实现方式。以下是一些关于虚拟 DOM 和性能之间关系的要点：

1. **减少真实 DOM 操作**：真实的 DOM 操作通常比 JavaScript 操作更昂贵和更慢。虚拟 DOM 的主要优势在于通过 diffing 算法减少必要的真实 DOM 操作。这意味着，对于大型 UI 更新，使用虚拟 DOM 可能会更快，因为它仅对发生变化的部分进行真实 DOM 更新。

2. **额外的开销**：虚拟 DOM 本身引入了一些开销。例如，每次状态变化都需要创建一个新的虚拟 DOM 树，然后与旧的虚拟 DOM 树进行比较。对于非常频繁的小型更新或非常简单的 UI，这种开销可能会使得虚拟 DOM 比直接操作真实 DOM 更慢。

3. **优化策略**：虚拟 DOM 实现通常包括一些优化策略，例如应用程序级别的 `shouldComponentUpdate` 方法或 `React.memo`，这可以帮助避免不必要的渲染和 diffing。

4. **大型列表和动画**：对于大型列表的频繁更新或高帧率的动画，虚拟 DOM 可能不是最佳选择，因为 diffing 过程可能无法在 16ms 内完成（为了实现 60fps 的动画）。在这种情况下，可能需要其他策略或直接使用真实 DOM 操作。

5. **初次渲染开销**：虽然虚拟 DOM 可以帮助优化后续的 UI 更新，但初次渲染时，应用程序需要构建初始的虚拟 DOM 树，这可能会稍微慢一些。

总的来说，虚拟 DOM 可以在很多场景中提高性能，特别是当直接的 DOM 操作变得昂贵时。但它并不总是更快，特别是对于小型更新或简单的 UI。如同任何工具或方法，了解其适用的场景和限制是关键。

## React的diff算法与传统的diff算法有什么区别？

React 的 diff 算法与传统的 diff 算法有一些关键的不同。首先，了解传统的 diff 算法：当我们说“传统的 diff 算法”，我们通常指的是用于比较两个文件（或两段文本）之间差异的算法，例如 Unix 中的 `diff` 工具。这种算法通常基于最长公共子序列 (LCS) 问题，并且在计算上可能相当昂贵。

现在，让我们看看 React 的 diff 算法与传统 diff 的不同之处：

1. **目的**：
   - 传统的 diff 算法：比较两个文本文件或字符串的差异。
   - React 的 diff 算法：比较两个虚拟 DOM 结构的差异。

2. **效率和优化**：
   - 传统的 diff 算法：尝试找到最小的差异集，这可能需要 O(n^3) 的时间复杂度。
   - React 的 diff 算法：React 采用了一些启发式策略来降低计算复杂度。例如，它假设两个不同类型的元素会产生不同的树，并且开发者不太可能在树的不同层次间改变元素。因此，React 的 diff 通常在实际应用中具有接近线性的性能。

3. **深度优先比较**：
   - React 的 diff 算法在比较虚拟 DOM 时采用深度优先策略。这意味着它会首先完成一个元素及其所有子元素的比较，然后再转到下一个同级元素。

4. **元素类型和键**：
   - React 的 diff 算法使用元素的类型和 `key` 属性作为线索。如果两个元素具有不同的类型，React 会假设它们是完全不同的，并重建整个子树。如果元素是相同类型的，React 会递归地比较它们的子元素。

5. **列表的比较**：
   - 传统的 diff 算法处理列表或数组时，尝试找到最小的差异集，这可能是非常昂贵的。
   - React 的 diff 算法利用了 `key` 属性来识别列表中的元素，这可以使比较过程更加高效。为列表中的每个元素提供稳定、唯一的 `key` 是优化性能的关键。

虽然 React 的 diff 算法与传统的 diff 算法在目标和方法上有所不同，但它们的核心思想是相似的：找出两个结构之间的差异，并以最有效的方式应用这些差异。但 React 的 diff 算法为特定的任务（即比较虚拟 DOM 结构）进行了优化，因此在实际应用中往往比传统算法更高效。

## diff策略有哪些？它们是如何比较的？

React 的 diff 算法采用了三种策略来减少 DOM 操作的数量，从而达到提高比较速度和效率的目的。这些策略基于两个基本假设：

1. 两个不同类型的元素会产生不同的树。
2. 开发者可以通过 `key` prop 提供一个稳定的标识来标记在不同渲染间稳定存在的子元素。

基于这些假设，React 的 diff 算法的策略如下：

1. **树级别的比较**：
   - React 首先比较两棵树的根元素。如果根元素的类型不同，React 将完全销毁旧树并构建新树。例如，`<a>` 与 `<img>` 之间的元素类型是不同的，所以 React 会移除 `<a>` 及其子孙，然后添加 `<img>`。
   - 对于自定义组件，如果组件类型不同，则进行整个树的重建。

2. **元素级别的比较**：
   - 当比较两个相同类型的 React 元素时，React 会保留 DOM 节点，并仅比较和修改之前和之后它们有差异的属性。例如，当属性样式发生变化时，React 只会更新特定的样式属性，而不是整个 `style` 对象。
   - 对于相同类型的组件元素，React 会保持同一个组件实例，而不是重新创建一个新的实例。

3. **列表子元素的比较**：
   - 当处理子元素数组时，React 依赖于为每个子元素设置的 `key` 属性来判定哪些子元素在不同的渲染中被保留。
   - 如果不提供 `key`，React 会按索引顺序进行比较，这可能会导致性能问题和组件状态丢失，因为它可能会错误地将不同的元素关联起来。
   - 有了 `key`，React 可以与旧的子元素数组进行匹配，更准确地确定哪些子元素被添加或移除。

总的来说，React 的 diff 算法通过这三种策略尽量减少需要重新渲染的部分，从而提高了更新的效率。这些策略利用了我们对 DOM 结构和常见更新模式的了解，以实现在大多数情况下的快速比较。


