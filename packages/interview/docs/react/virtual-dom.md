# 虚拟DOM及diff算法

虚拟 DOM (Virtual DOM) 是一种编程概念，其中 UI 的表示是由虚拟节点或虚拟节点树表示的，而不是直接映射到实际的 DOM。它充当了真实 DOM 和应用状态之间的中介。虚拟 DOM 提供了一种能够在不直接操作 DOM 的情况下更新视图的机制。主要的目标是通过避免直接的 DOM 操作来提高应用的性能，因为直接的 DOM 操作通常比纯 JavaScript 和虚拟 DOM 操作要慢得多。

## 虚拟DOM 如何工作

1. **UI 表示**：应用的 UI 被表示为虚拟 DOM 树的结构。

2. **修改**：当应用的状态变化时，会生成一个新的虚拟 DOM 树。

3. **对比**：新的虚拟 DOM 树与前一个树进行对比，使用一个叫做 "diffing" 的过程。这个过程会确定两棵树之间的具体差异。

4. **更新**：一旦知道了差异，就会更新真实的 DOM 来匹配新的虚拟 DOM 树，但只会更新发生变化的部分，而不是重新渲染整个 UI。这种更新方式被称为 "patching"。

这种机制能够帮助提高性能的主要原因：

1. **减少实际 DOM 操作**：直接操作 DOM 通常是缓慢的，尤其是大量的读/写操作时。虚拟 DOM 机制限制了这些操作的数量。

2. **批量和延迟的更新**：多个修改可以在虚拟 DOM 中累积，然后一次性更新真实 DOM，而不是为每个小的改变都触发更新。

3. **更少的重绘和重流**：浏览器的渲染引擎会尝试优化渲染过程，但频繁的 DOM 更新可能会导致不必要的重绘和重流。通过限制 DOM 更新的数量，虚拟 DOM 可以帮助减少这些操作，从而提高性能。

4. **JS 的速度优势**：虚拟 DOM 的 diffing 和 patching 过程完全在 JavaScript 中进行，而 JavaScript 通常比 DOM 操作更快。

虚拟 DOM 不仅仅存在于 React 中（尽管 React 可能是最知名的库，使用了虚拟 DOM），还有其他许多前端库和框架也实现了自己的虚拟 DOM 或类似的概念。

## 有了虚拟DOM，性能就一定能够得到提升吗？

不一定，虚拟 DOM 并不是性能的银弹。有了虚拟 DOM，性能不一定总是得到提升，而是取决于具体的使用场景和实现方式。以下是一些关于虚拟 DOM 和性能之间关系的要点：

1. **减少真实 DOM 操作**：真实的 DOM 操作通常比 JavaScript 操作更昂贵和更慢。虚拟 DOM 的主要优势在于通过 diffing 算法减少必要的真实 DOM 操作。这意味着，对于大型 UI 更新，使用虚拟 DOM 可能会更快，因为它仅对发生变化的部分进行真实 DOM 更新。

2. **额外的开销**：虚拟 DOM 本身引入了一些开销。例如，每次状态变化都需要创建一个新的虚拟 DOM 树，然后与旧的虚拟 DOM 树进行比较。对于非常频繁的小型更新或非常简单的 UI，这种开销可能会使得虚拟 DOM 比直接操作真实 DOM 更慢。

3. **优化策略**：虚拟 DOM 实现通常包括一些优化策略，例如应用程序级别的 `shouldComponentUpdate` 方法或 `React.memo`，这可以帮助避免不必要的渲染和 diffing。

4. **大型列表和动画**：对于大型列表的频繁更新或高帧率的动画，虚拟 DOM 可能不是最佳选择，因为 diffing 过程可能无法在 16ms 内完成（为了实现 60fps 的动画）。在这种情况下，可能需要其他策略或直接使用真实 DOM 操作。

5. **初次渲染开销**：虽然虚拟 DOM 可以帮助优化后续的 UI 更新，但初次渲染时，应用程序需要构建初始的虚拟 DOM 树，这可能会稍微慢一些。

总的来说，虚拟 DOM 可以在很多场景中提高性能，特别是当直接的 DOM 操作变得昂贵时。但它并不总是更快，特别是对于小型更新或简单的 UI。如同任何工具或方法，了解其适用的场景和限制是关键。

## React的diff算法与传统的diff算法有什么区别？

React 的 diff 算法与传统的 diff 算法有一些关键的不同。首先，了解传统的 diff 算法：当我们说“传统的 diff 算法”，我们通常指的是用于比较两个文件（或两段文本）之间差异的算法，例如 Unix 中的 `diff` 工具。这种算法通常基于最长公共子序列 (LCS) 问题，并且在计算上可能相当昂贵。

现在，让我们看看 React 的 diff 算法与传统 diff 的不同之处：

1. **目的**：
   - 传统的 diff 算法：比较两个文本文件或字符串的差异。
   - React 的 diff 算法：比较两个虚拟 DOM 结构的差异。

2. **效率和优化**：
   - 传统的 diff 算法：尝试找到最小的差异集，这可能需要 O(n^3) 的时间复杂度。
   - React 的 diff 算法：React 采用了一些启发式策略来降低计算复杂度。例如，它假设两个不同类型的元素会产生不同的树，并且开发者不太可能在树的不同层次间改变元素。因此，React 的 diff 通常在实际应用中具有接近线性的性能。

3. **深度优先比较**：
   - React 的 diff 算法在比较虚拟 DOM 时采用深度优先策略。这意味着它会首先完成一个元素及其所有子元素的比较，然后再转到下一个同级元素。

4. **元素类型和键**：
   - React 的 diff 算法使用元素的类型和 `key` 属性作为线索。如果两个元素具有不同的类型，React 会假设它们是完全不同的，并重建整个子树。如果元素是相同类型的，React 会递归地比较它们的子元素。

5. **列表的比较**：
   - 传统的 diff 算法处理列表或数组时，尝试找到最小的差异集，这可能是非常昂贵的。
   - React 的 diff 算法利用了 `key` 属性来识别列表中的元素，这可以使比较过程更加高效。为列表中的每个元素提供稳定、唯一的 `key` 是优化性能的关键。

虽然 React 的 diff 算法与传统的 diff 算法在目标和方法上有所不同，但它们的核心思想是相似的：找出两个结构之间的差异，并以最有效的方式应用这些差异。但 React 的 diff 算法为特定的任务（即比较虚拟 DOM 结构）进行了优化，因此在实际应用中往往比传统算法更高效。

## React diff策略有哪些？

React 的 diff 算法采用了三种策略来减少 DOM 操作的数量，从而达到提高比较速度和效率的目的。这些策略基于两个基本假设：

1. 两个不同类型的元素会产生不同的树。
2. 开发者可以通过 `key` prop 提供一个稳定的标识来标记在不同渲染间稳定存在的子元素。

基于这些假设，React 的 diff 算法的策略如下：

1. **tree diff**：
   - React 首先比较两棵树的根元素。如果根元素的类型不同，React 将完全销毁旧树并构建新树。例如，`<a>` 与 `<img>` 之间的元素类型是不同的，所以 React 会移除 `<a>` 及其子孙，然后添加 `<img>`。
   - 对于自定义组件，如果组件类型不同，则进行整个树的重建。

2. **component diff**：
组件比较，React对于组件的策略有两种方式，一种是相同类型的组件和不同类型的组件
- 对同种类型组件对比，按照层级比较继续比较虚拟DOM树即可，但有种特殊的情况，当组件A如果变化为组件B的时候，有可能虚拟DOM并没有任何变化，所以用户可以通过shouldComponentUpdate() 来判断是否需要更新，判断是否计算
- 对于不同组件来说，React会直接判定该组件为dirty component（脏组件），无论结构是否相似，只要判断为脏组件就会直接替换整个组件的所有节点

3. **element diff**：
- 按元素类型进行比较
React 首先检查两个元素的类型。如果类型不同，React 会删除原来的所有子树，然后用新元素替换整个 DOM 子树。

例如，当一个元素从 `<div>` 变为 `<span>`，React 将会移除 `<div>` 及其所有子元素，并创建一个新的 `<span>` 及其子元素。

- 按 `key` 进行比较
当比较同类型的组合组件（比如列表）时，React 依赖 `key` 属性来区分它们。具有相同 `key` 的元素会被复用，然后只更新必要的部分。

```jsx
// 旧的 Virtual DOM
<ul>
  <li key="1">Apple</li>
  <li key="2">Banana</li>
  <li key="3">Cherry</li>
</ul>

// 新的 Virtual DOM
<ul>
  <li key="1">Apple</li>
  <li key="3">Cherry</li>
  <li key="2">Banana</li>
</ul>
```

在这个例子中，React 会识别出元素只是进行了位置交换，然后执行相应的 DOM 操作来交换元素，而不是删除和重新创建元素。

- 同一类型元素的属性比较
如果两个元素是同一类型的，React 会保留 DOM 节点，并且仅比较和更新有变化的属性。例如，当样式从 `{color: 'red'}` 变为 `{color: 'green'}`，React 只会更新 `color` 属性，而不会重新创建整个元素。


## 它们是如何比较的？

1. **按层级比较**

    React只对同一层级元素进行diff。如果一个组件在更新过程中被移动到另一个父节点，React会不复用原来组件，而是重新渲染。

    ```jsx
    // 原结构
    <div>
        <ComponentA />
    </div>

    // 更新后结构
    <span>
        <ComponentA />
    </span>
    ```
    
    在上面的例子中，`ComponentA`即使没有变化，也会被重新渲染。

2. **类型相同的节点**

    当新旧节点类型相同时，React会保留DOM节点，只更新必要的属性。

    ```jsx
    // 旧
    <div className="old" />

    // 新
    <div className="new" />

    // 结果：仅className会被更新。
    ```

3. **类型不同的节点**

    当元素类型不同时，React会销毁旧节点并创建新节点。

    ```jsx
    // 旧
    <div />

    // 新
    <span />

    // 结果：旧的`<div>`将被销毁，新的`<span>`将被创建。
    ```

4. **列表元素的Key**

    当渲染列表元素时，应该给每个元素一个唯一的`key`属性，这样React才能识别和复用它们。

    ```jsx
    // 好的做法
    items.map(item => <li key={item.id}>{item.name}</li>)

    // 不好的做法
    items.map((item, index) => <li key={index}>{item.name}</li>)
    ```

### 代码解析

下面是一个简化的diff算法的代码解析：

```javascript
function diff(oldTree, newTree) {
  let patches = {}; // 存放所有变更
  let index = 0;
  
  walk(oldTree, newTree, index, patches);
  return patches;

  function walk(oldNode, newNode, index, patches) {
    let currentPatches = [];

    if (!newNode) {
      // 节点被删除
    } else if (isString(oldNode) && isString(newNode)) {
      // 文本节点
      if (oldNode !== newNode) {
        currentPatches.push({ type: 'TEXT', text: newNode });
      }
    } else if (oldNode.type === newNode.type) {
      // 节点相同，比较属性
      let attrsPatches = diffAttrs(oldNode.props, newNode.props);
      if (Object.keys(attrsPatches).length > 0) {
        currentPatches.push({ type: 'ATTRS', attrs: attrsPatches });
      }
      // 比较子节点
      diffChildren(oldNode.children, newNode.children, patches);
    } else {
      // 节点不相同，直接替换
      currentPatches.push({ type: 'REPLACE', newNode });
    }

    if (currentPatches.length) {
      patches[index] = currentPatches;
    }
  }
}
```

这个简化的代码片段展示了一个非常基础版本的React diff算法，目的是帮助理解其核心逻辑。

这里的diff算法会递归地遍历旧的Virtual DOM树，并与新的Virtual DOM树进行比较，然后记录下所有的差异（patches）。然后这些差异可以用来更新DOM。

## 时间复杂度

React 的 diff 算法具有近似为 O(n) 的时间复杂度。这是相当高效的，特别是与传统的 diff 算法（通常具有 O(n^3) 的时间复杂度）相比。

这样的性能得益于 React 的几个简化假设：

1. **两个不同类型的元素会生成不同的树**：这意味着如果元素类型改变了，React 不会尝试比较和更新，而是直接卸载旧树并建立一个全新的树。

2. **通过 `key` 属性可以标识稳定的子元素**：这简化了列表中元素的添加、删除和重新排序的复杂性。

因此，在大多数实际应用场景中，React 的这种 "heuristic"（启发式）算法通常足够快，以至于用户无法感觉到任何性能下降。

需要注意的是，虽然大多数情况下这种算法是有效的，但如果你的应用有特殊的性能需求，还是需要进行具体的性能优化。React DevTools 提供了一种方式来检查组件重新渲染的原因，这有助于你找出可能的性能瓶颈。

React 的 diff 算法在时间复杂度方面表现得相当不错，这也是它能在复杂 UI 更新中保持高性能的一个重要原因。

##  传统的 diff 算法时间复杂度为什么是 O(n^3)

传统的 diff 算法主要用于比较两个序列（例如，两个字符串或两个文件）以找出最小编辑距离。最小编辑距离通常是通过动态规划来解决的，而这样的解法一般具有 O(n^2) 的时间复杂度。

然而，当应用于树形结构（如 DOM 树或其他层级数据结构）时，寻找两个树之间的最小差异（编辑距离）变得更加复杂。在这种情况下，传统的 diff 算法可能需要对树的每一个节点进行比较，以找出最优的转换方法，这通常具有 O(n^3) 的时间复杂度。

为什么是 O(n^3)？假设我们有两棵树，每棵树都有 N 个节点。对于第一棵树中的每一个节点，算法都需要去找第二棵树中与之相对应的最佳匹配节点。这一匹配过程本身就是一个求解最小编辑距离的问题，其时间复杂度通常是 O(N^2)。由于我们需要对每一个节点都做这样的操作，所以总体时间复杂度就成了 O(N^3)。

然而，React 的 diff 算法通过一些启发式方法和假设，将这个复杂度降低到近似 O(n)，这使得其在实际应用中的性能非常出色。